<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Nollstead Studio BTAudio – Firmware Uploader</title>

  <!-- We use the single-file bundle for simplicity -->
  <script>
    // Ensure this page is served over HTTPS/GitHub Pages. Web Serial requires secure context.
    // Chrome/Edge only (experimental API). See: https://developer.chrome.com/docs/capabilities/serial
  </script>

  <style>
    :root{--bg:#121212;--panel:#1e1e1e;--text:#eaeaea;--muted:#bbb;--accent:#4CAF50;--accent2:#43a047;--border:rgba(255,255,255,.08)}
    *{box-sizing:border-box}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;max-width:780px;margin:48px auto;padding:20px;background:var(--bg);color:var(--text);line-height:1.6}
    h1{margin:0 0 8px}.muted{color:var(--muted)}
    .panel{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:20px;margin:18px 0;box-shadow:0 0 20px rgba(0,0,0,.35)}
    .row{display:flex;gap:10px;flex-wrap:wrap;margin:16px 0}
    button{background:var(--accent);color:#fff;border:none;padding:12px 18px;border-radius:10px;font-weight:600;cursor:pointer}
    button[disabled]{opacity:.55;cursor:not-allowed}
    button:hover:not([disabled]){background:var(--accent2)}
    textarea{width:100%;height:240px;border-radius:8px;border:1px solid var(--border);background:#0f0f0f;color:#cfe8ff;padding:10px;font-family:ui-monospace,Menlo,Consolas,monospace}
  </style>
</head>
<body>
  <h1>BTAudio Firmware Uploader v28</h1>
  <p class="muted">Version 0.0.2</p>

  <div class="panel">
    <div class="row">
      <button id="connectBtn" disabled>1) Connect</button>
      <button id="flashBtn"   disabled>2) Upload</button>
      <button id="resetBtn"   disabled>3) Reset</button>
      <button id="disconnectBtn" disabled>4) Disconnect</button>
    </div>
    <p class="muted">
      If it doesn’t auto‑reboot, click <b>Reset</b> or press the board’s <b>RESET (EN)</b> button.
    </p>
  </div>

  <div class="panel">
    <h3>Log</h3>
    <textarea id="log" readonly></textarea>
  </div>

  <!-- Script: hardened connect/disconnect for CH340 + esptool-js -->
  <script type="module">
    import * as esptool from 'https://unpkg.com/esptool-js@0.5.7/bundle.js';

    const { ESPLoader, Transport } = esptool;

    const logEl       = document.getElementById('log');
    const connectBtn  = document.getElementById('connectBtn');
    const flashBtn    = document.getElementById('flashBtn');
    const resetBtn    = document.getElementById('resetBtn');
    const disconnectBtn = document.getElementById('disconnectBtn');

    let port = null;
    let loader = null;
    let transport = null;
    let connecting = false;                 // guards against double-click races
    const BAUD = 460800;                    // can try 921600 if stable

    const log = (m, e=false) => {
      const ts = new Date().toLocaleTimeString();
      logEl.value += `[${ts}] ${m}\n`;
      logEl.scrollTop = logEl.scrollHeight;
      (e ? console.error : console.log)(m);
    };

    const espTerminal = {
      clean(){ logEl.value = ""; },
      writeLine(s){ log(s); },
      write(s){ log(s); }
    };

    const sleep = (ms) => new Promise(r => setTimeout(r, ms));

    // Windows usbser.sys sometimes needs double-set (RTS quirk). WICG issue thread references this.
    async function setSignalsTwice(dtr, rts) {
      await port.setSignals({ dataTerminalReady: dtr, requestToSend: rts }).catch(()=>{});
      await port.setSignals({ dataTerminalReady: dtr, requestToSend: rts }).catch(()=>{});
    }

    /**
     * Enter the ROM bootloader using DTR/RTS.
     * We open the port *temporarily* only for signal toggling and close in finally.
     * Used only as a recovery attempt after a failed connect.
     */
    async function enterBootloaderOnce() {
      if (!port) return;

      // Web Serial requires the port to be OPEN to call setSignals()
      await port.open({ baudRate: BAUD }).catch(()=>{});

      try {
        await setSignalsTwice(true,  true);   // GPIO0=LOW (DTR=true), EN=LOW (RTS=true)
        await sleep(80);

        await setSignalsTwice(true,  false);  // EN=HIGH, keep GPIO0 LOW
        await sleep(80);

        await setSignalsTwice(false, false);  // release GPIO0, EN stays HIGH
        await sleep(50);
      } finally {
        try { await port.close(); } catch {}
      }

      await sleep(150); // small settle for CH340
    }

    // Close any granted ports (same origin) that might still be open.
    async function closeAllGrantedPorts() {
      try {
        const granted = await navigator.serial.getPorts();
        for (const p of granted) {
          try { await p.close(); } catch {}
        }
      } catch {}
    }

    async function disconnectClean() {
      try {
        // First, ask esptool-js transport to unlock streams (important for Web Serial close)
        try { await transport?.disconnect?.(); } catch {}
        try { await loader?.flashFinish?.(false); } catch {}
      } finally {
        try { await port?.close(); } catch {}
        try { await port?.forget?.(); } catch {}
        try { await closeAllGrantedPorts(); } catch {}
        await sleep(150);
        loader = null; transport = null; port = null;
        connectBtn.disabled = false;
        flashBtn.disabled = true;
        resetBtn.disabled = true;
        disconnectBtn.disabled = true;
        log("Disconnected and port closed.");
        connectBtn.focus();
      }
    }
    disconnectBtn.onclick = disconnectClean;

    // RTS/DTR reset to boot flashed app (GPIO0 high, EN pulse)
    async function hardResetToApp(){
      if(!port) return;
      try{
        await port.setSignals({ dataTerminalReady: false }); // DTR=false -> GPIO0 HIGH
        await port.setSignals({ requestToSend: true  });      // RTS=true  -> EN low
        await sleep(120);
        await port.setSignals({ requestToSend: false });      // EN high
        log("Issued RTS/DTR reset (normal boot).");
      }catch(e){ log(`Reset sequence failed: ${e?.message || e}`, true); }
    }

    // Optional: auto-clean if the cable is pulled
    navigator.serial?.addEventListener?.('disconnect', async (e) => {
      if (port && e.target === port) {
        log('Device disconnected.');
        await disconnectClean();
      }
    });

    // === Hardened connect flow ===
    connectBtn.onclick = async () => {
      if (connecting) return;
      connecting = true;
      connectBtn.disabled = true;

      try{
        if (!('serial' in navigator)) {
          throw new Error("WebSerial not available. Use Chrome/Edge over HTTPS.");
        }

        // Close lingering same-origin ports (helps if another tab left it open)
        await closeAllGrantedPorts();
        await sleep(100);

        // Prefer CH340 (CH34x) by VID/PID; fall back to generic selection if not found
        const filters = [{ usbVendorId: 0x1a86, usbProductId: 0x7523 }]; // CH340 on your board
        try {
          port = await navigator.serial.requestPort({ filters });
        } catch (e) {
          if (String(e?.name) === 'NotFoundError') {
            port = await navigator.serial.requestPort({});
          } else {
            throw e;
          }
        }
        log('Port selected.');

        // Force closed state before esptool-js touches it (driver stickiness)
        try { await port.close(); } catch {}
        await sleep(100);

        // Build transport/loader. Do NOT open here — esptool-js will open during connect().
        transport = new Transport(port, /* tracing */ false, /* enableSlipReader */ false);
        loader    = new ESPLoader({ transport, baudrate: BAUD, terminal: espTerminal });

        try {

// Ensure the port is really closed before esptool-js opens it
if (port.readable || port.writable) {
  try { await transport?.disconnect?.(); } catch {}
  try { await port.close(); } catch {}
  await sleep(150);
}
          await loader.connect(); // esptool-js calls port.open() internally
        } catch (firstErr) {
          // Recovery: try bootloader entry once and reconnect
          log(`First connect failed: ${firstErr?.message || firstErr}`, true);
          try { await port?.close(); } catch {}
          await sleep(200);

          await enterBootloaderOnce();

          try { await port?.close(); } catch {}
          await sleep(150);

          transport = new Transport(port, /* tracing */ false, /* enableSlipReader */ false);
          loader    = new ESPLoader({ transport, baudrate: BAUD, terminal: espTerminal });


// Ensure the port is really closed before esptool-js opens it
if (port.readable || port.writable) {
  try { await transport?.disconnect?.(); } catch {}
  try { await port.close(); } catch {}
  await sleep(150);
}
          await loader.connect();
        }

        const chip = await loader.chip;
        log('Connected');

        flashBtn.disabled = false;
        resetBtn.disabled = false;
        disconnectBtn.disabled = false;
      } catch (e) {
        log(`Connect failed: ${e?.name ? e.name+': ' : ''}${e?.message || e}`, true);

        // Unwind state so the next attempt starts clean
        try { await transport?.disconnect?.(); } catch {}
        try { await port?.close(); } catch {}
        await sleep(150);

        connectBtn.disabled = false;
      } finally {
        connecting = false;
      }
    };

    // === Flash flow (kept close to your original, with minor guardrails) ===
    flashBtn.onclick = async () => {
      flashBtn.disabled = true;
      try {
        const resp = await fetch("webflash/UTAudio.bin", { cache: "no-cache" });
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const buf = new Uint8Array(await resp.arrayBuffer());
        log(`Image size: ${buf.length} bytes`);

        // Load stub if needed (faster, more reliable erase/write)
        try {
          if (!loader.IS_STUB) {
            log("Running stub…");
            await (typeof loader.runStub === 'function' ? loader.runStub() : loader.loadStub());
            log("Stub ready.");
          } else {
            log("Stub already running — skipping stub load.");
          }
        } catch (e) {
          const msg = String(e?.message || e);
          if (/software loader is resident|overlapping address range/i.test(msg)) {
            log("Stub already resident — continuing without reloading.");
          } else {
            log("Stub failed (continuing with ROM bootloader): " + msg, true);
          }
        }

        // Full erase for safety (you can comment this out for faster updates)
        await loader.eraseFlash();

        // Convert Uint8Array -> binary string for esptool-js@0.5.7 browser bundle
        let bstr = '';
        for (let i = 0; i < buf.length; i++) bstr += String.fromCharCode(buf[i]);

        await loader.writeFlash({
          fileArray: [{ address: 0x000000, data: bstr }],
          flashSize: '16MB',     // SparkFun Thing Plus WROOM-32E is 16MB
          flashMode: 'keep',
          flashFreq: 'keep',
          compress: true,
          reportProgress: (fileIndex, written, total) => {
            if (total > 0) log(`Writing… ${Math.round((written/total)*100)}%`);
          }
        });

        log("Flash complete. Wrapping up…");
        await hardResetToApp();
        log("Done.");

        // Auto-disconnect so next run starts clean
        await disconnectClean();

      } catch (e) {
        log(`Flash failed: ${e?.message || e}`, true);
        // Keep session alive to allow retry
        flashBtn.disabled = false;
      }
    };

    resetBtn.onclick = async () => {
      await hardResetToApp();
    };

    // Release the port on tab close/reload so a fresh load doesn't inherit a locked handle
    window.addEventListener('unload', () => {
      // Fire and forget; the browser may ignore async but it still helps
      try { transport?.disconnect?.(); } catch
      try { port?.close(); } catch {}
    });

    // Initial enablement
    log("Installer script loaded.");
    connectBtn.disabled = !(Transport && ESPLoader);
  </script>
</body>
</html>
