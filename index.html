
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Nollstead Studio BTAudio – Firmware Uploader</title>
  <style>
    :root{--bg:#121212;--panel:#1e1e1e;--text:#eaeaea;--muted:#bbb;--accent:#4CAF50;--accent2:#43a047;--border:rgba(255,255,255,.08)}
    *{box-sizing:border-box}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;max-width:780px;margin:48px auto;padding:20px;background:var(--bg);color:var(--text);line-height:1.6}
    h1{margin:0 0 8px}.muted{color:var(--muted)}
    .panel{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:20px;margin:18px 0;box-shadow:0 0 20px rgba(0,0,0,.35)}
    .row{display:flex;gap:10px;flex-wrap:wrap;margin:16px 0}
    .instructions{background:#1e1e1e;border-radius:14px;padding:18px;margin-top:10px}
    button{background:var(--accent);color:#fff;border:none;padding:12px 18px;border-radius:10px;font-weight:600;cursor:pointer}
    button[disabled]{opacity:.55;cursor:not-allowed}
    button:hover:not([disabled]){background:var(--accent2)}
    textarea{width:100%;height:260px;border-radius:8px;border:1px solid var(--border);background:#0f0f0f;color:#cfe8ff;padding:10px;font-family:ui-monospace,Menlo,Consolas,monospace}
  </style>
</head>
<body>
  <h1>BTAudio Firmware Uploader v45</h1>
  <p class="muted">Re‑plug to connect (no BOOT/RESET buttons required)</p>

  <div class="panel">
    <div class="row">
      <button id="connectBtn" disabled>Connect</button>
      <button id="flashBtn"   disabled>Upload</button>
      <button id="resetBtn"   disabled>Reset</button>
      <button id="disconnectBtn" disabled>Disconnect</button>
    </div>
    <div class="instructions">
      <ol>
        <li>Click <b>Connect</b>. The page will ask you to <b>unplug</b> the device, then <b>plug it back in</b>.</li>
        <li>Select the <b>USB‑SERIAL</b> port when prompted.</li>
        <li>Click <b>Upload</b> to flash. The board will restart automatically afterward.</li>
      </ol>
      <p class="muted">Tip: If a connection ever fails, simply unplug and re‑plug, then click Connect again.</p>
    </div>
  </div>

  <div class="panel">
    <h3>Log</h3>
    <textarea id="log" readonly></textarea>
  </div>

  <!-- Static import of a version-pinned esptool-js bundle -->
  <script type="module">
    import * as esptool from 'https://unpkg.com/esptool-js@0.5.7/bundle.js';
    const { ESPLoader, Transport } = esptool;

    // ---- DOM & log ----
    const logEl = document.getElementById('log');
    const connectBtn = document.getElementById('connectBtn');
    const flashBtn = document.getElementById('flashBtn');
    const resetBtn = document.getElementById('resetBtn');
    const disconnectBtn = document.getElementById('disconnectBtn');

    const log = (m, e=false) => {
      const ts = new Date().toLocaleTimeString();
      logEl.value += `[${ts}] ${m}\n`;
      logEl.scrollTop = logEl.scrollHeight;
      (e ? console.error : console.log)(m);
    };

    // ---- State & constants ----
    let port = null, loader = null, transport = null, connecting = false;
    let waitingForReplug = false, sawDisconnect = false;

    const BAUD = 115200;  // conservative first sync on CH340C
    const CH340_FILTERS = [{ usbVendorId: 0x1a86, usbProductId: 0x7523 }];
    const sleep = (ms) => new Promise(r => setTimeout(r, ms));

    // Track OS-level disconnects during the re-plug flow
    navigator.serial?.addEventListener?.('disconnect', () => {
      if (waitingForReplug) sawDisconnect = true;
    });

    async function disconnectClean() {
      try {
        try { await transport?.disconnect?.(); } catch {}
        try { await loader?.flashFinish?.(false); } catch {}
      } finally {
        try { await port?.close?.(); } catch {}
        await sleep(150);
        loader = null; transport = null; port = null;

        connectBtn.disabled = false;
        flashBtn.disabled = true;
        resetBtn.disabled = true;
        disconnectBtn.disabled = true;

        log('Disconnected and port closed.');
      }
    }
    disconnectBtn.onclick = disconnectClean;

    // ---- Connect: re-plug to get a clean first open, then let esptool-js do the default reset ----
    connectBtn.onclick = async () => {
      if (connecting) return;
      connecting = true;
      connectBtn.disabled = true;

      try {
        if (!('serial' in navigator)) {
          throw new Error('WebSerial not available. Use Chrome/Edge over HTTPS.');
        }

        // Ask the user to physically re-plug the device to get a clean enumeration
        waitingForReplug = true;
        sawDisconnect = false;
        log('Please UNPLUG the device now… waiting up to 15s.');
        {
          const start = Date.now();
          while (!sawDisconnect && (Date.now() - start) < 15000) {
            await sleep(100);
          }
          if (!sawDisconnect) throw new Error('No disconnect detected. Unplug the cable, then try again.');
        }

        log('Great. Now PLUG IT BACK IN and select the port when prompted…');
        await sleep(600);  // small grace for enumeration

        try {
          port = await navigator.serial.requestPort({ filters: CH340_FILTERS });
        } catch (e) {
          // If the chooser was cancelled or port selection failed:
          throw e;
        }
        log('Port selected.');

        // Build transport/loader and connect — use esptool-js default reset strategy
        transport = new Transport(port, /* tracing */ false, /* enableSlipReader */ false);
        loader = new ESPLoader({
          transport,
          baudrate: BAUD,
          terminal: { clean(){ logEl.value=''; }, writeLine(s){ log(s); }, write(s){ log(s); } }
        });

        // Make sure nothing is open before connect
        if (port.readable || port.writable) {
          try { await transport?.disconnect?.(); } catch {}
          try { await port.close(); } catch {}
          await sleep(150);
        }

        await loader.connect();  // esptool-js performs the standard DevKit-style auto-reset here

        const chip = await loader.chip;
        log(`Connected (${chip})`);
        flashBtn.disabled = false;
        resetBtn.disabled = false;
        disconnectBtn.disabled = false;

      } catch (e) {
        log(`Connect failed: ${e?.name ? e.name+': ' : ''}${e?.message || e}`, true);
        try { await transport?.disconnect?.(); } catch {}
        try { await port?.close?.(); } catch {}
        await sleep(150);

        flashBtn.disabled = true;
        resetBtn.disabled = true;
        disconnectBtn.disabled = true;
        connectBtn.disabled = false;
      } finally {
        waitingForReplug = false;
        connecting = false;
      }
    };

    // ---- Flash flow (single image example) ----
    flashBtn.onclick = async () => {
      flashBtn.disabled = true;
      try {
        const resp = await fetch('webflash/UTAudio.bin', { cache: 'no-cache' });
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const buf = new Uint8Array(await resp.arrayBuffer());
        log(`Image size: ${buf.length} bytes`);

        try {
          if (!loader.IS_STUB) {
            log('Running stub…');
            await (typeof loader.runStub === 'function' ? loader.runStub() : loader.loadStub());
            log('Stub ready.');
          } else {
            log('Stub already running — skipping stub load.');
          }
        } catch (e) {
          log(`Stub load failed (continuing): ${e?.message || e}`, true);
        }

        await loader.eraseFlash();

        // Uint8Array -> binary string for esptool-js 0.5.7 bundle
        let bstr = '';
        for (let i = 0; i < buf.length; i++) bstr += String.fromCharCode(buf[i]);

        await loader.writeFlash({
          fileArray: [{ address: 0x000000, data: bstr }],
          flashSize: '16MB',
          flashMode: 'keep',
          flashFreq: 'keep',
          compress: true,
          reportProgress: (idx, written, total) => {
            if (total > 0) log(`Writing… ${Math.round((written/total)*100)}%`);
          }
        });

        log('Flash complete.');
        // esptool-js usually resets after flashing; we then close everything so next use starts clean
        await disconnectClean();
        log('To connect again, please UNPLUG and re‑PLUG the device, then click Connect.');

      } catch (e) {
        log(`Flash failed: ${e?.message || e}`, true);
        flashBtn.disabled = false;
      }
    };

    // Optional: keep a Reset button for UX clarity
    resetBtn.onclick = async () => {
      log('Reset is handled automatically after flashing. Disconnecting instead…');
      await disconnectClean();
    };

    // Release the port on tab close/reload
    window.addEventListener('unload', () => {
      try { transport?.disconnect?.(); } catch {}
      try { port?.close?.(); } catch {}
    });

    log('Installer script loaded.');
    connectBtn.disabled = !(Transport && ESPLoader);
  </script>
</body>
</html>
