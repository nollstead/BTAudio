<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Nollstead Studio BTAudio – Firmware Uploader</title>
  <style>
    :root{--bg:#121212;--panel:#1e1e1e;--text:#eaeaea;--muted:#bbb;--accent:#4CAF50;--accent2:#43a047;--border:rgba(255,255,255,.08)}
    *{box-sizing:border-box}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;max-width:780px;margin:48px auto;padding:20px;background:var(--bg);color:var(--text);line-height:1.6}
    h1{margin:0 0 8px}.muted{color:var(--muted)}
    .panel{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:20px;margin:18px 0;box-shadow:0 0 20px rgba(0,0,0,.35)}
    .row{display:flex;gap:10px;flex-wrap:wrap;margin:16px 0}
    .instructions{background:#1e1e1e;border-radius:14px;padding:18px;margin-top:10px}
    button{background:var(--accent);color:#fff;border:none;padding:12px 18px;border-radius:10px;font-weight:600;cursor:pointer}
    button[disabled]{opacity:.55;cursor:not-allowed}
    button:hover:not([disabled]){background:var(--accent2)}
    textarea{width:100%;height:260px;border-radius:8px;border:1px solid var(--border);background:#0f0f0f;color:#cfe8ff;padding:10px;font-family:ui-monospace,Menlo,Consolas,monospace}
  </style>
</head>
<body>
  <h1>BTAudio Firmware Uploader v42</h1>
  <p class="muted">SparkFun CH340C reset handling</p>

  <div class="panel">
    <div class="row">
      <button id="connectBtn" disabled>Connect</button>
      <button id="flashBtn"   disabled>Upload</button>
      <button id="resetBtn"   disabled>Reset</button>
      <button id="disconnectBtn" disabled>Disconnect</button>
    </div>
    <div class="instructions">
      <ol>
        <li>Click <b>Connect</b> and select the <b>USB‑SERIAL</b> port.</li>
        <li>Click <b>Upload</b> to flash. The board should reboot automatically afterward.</li>
        <li>If connect fails, try a different USB cable or a USB‑2.0 port and retry.</li>
      </ol>
    </div>
  </div>

  <div class="panel">
    <h3>Log</h3>
    <textarea id="log" readonly></textarea>
  </div>

  <!-- Static import of a version-pinned bundle -->
  <script type="module">
    import * as esptool from 'https://unpkg.com/esptool-js@0.5.7/bundle.js';
    const { ESPLoader, Transport } = esptool;

    // --- DOM & log -----------------------------------------------------------
    const logEl = document.getElementById('log');
    const connectBtn = document.getElementById('connectBtn');
    const flashBtn = document.getElementById('flashBtn');
    const resetBtn = document.getElementById('resetBtn');
    const disconnectBtn = document.getElementById('disconnectBtn');

    const log = (m, e=false) => {
      const ts = new Date().toLocaleTimeString();
      logEl.value += `[${ts}] ${m}\n`;
      logEl.scrollTop = logEl.scrollHeight;
      (e ? console.error : console.log)(m);
    };

    // --- State & constants ---------------------------------------------------
    let port = null, loader = null, transport = null, connecting = false;
    let lastDisconnectAt = Date.now() - (60*60*1000);
    const RECONNECT_DELAY_MS = 5000;
    const BAUD = 115200; // safer first sync on CH340C
    const CH340_FILTERS = [{ usbVendorId: 0x1a86, usbProductId: 0x7523 }];

    const sleep = (ms) => new Promise(r => setTimeout(r, ms));

    async function closeAllGrantedPorts() {
      try {
        const granted = await navigator.serial.getPorts();
        for (const p of granted) { try { await p.close(); } catch {} }
      } catch {}
    }


// SparkFun boot entry using esptool-js Transport + CustomReset
// Sequence per SparkFun note: RTS HIGH (R0), DTR LOW->HIGH (D1 -> W -> D0)
async function enterBootloaderSparkfun_viaTransport() {
  if (!port) return;

  // Build a temporary Transport and OPEN it to be able to toggle lines
  const tmpTransport = new Transport(port, /* tracing */ false, /* enableSlipReader */ false);

  try {
    await tmpTransport.connect(BAUD);

    // Use esptool-js custom reset string (active-low semantics):
    // R0 (RTS=HIGH), D1 (DTR=LOW), W120, D0 (DTR=HIGH), W80
    const seq = 'R0|D1|W120|D0|W80';

    // CustomReset class exposes .reset()
    const custom = new esptool.CustomReset(tmpTransport, seq);
    await custom.reset();

    // leave both deasserted (safety)
    await tmpTransport.setRTS(false); // RTS HIGH (deassert)
    await tmpTransport.setDTR(false); // DTR HIGH (deassert)

  } finally {
    // CLOSE the temporary Transport so we start fresh for loader.connect()
    try { await tmpTransport.disconnect(); } catch {}
    await sleep(200);
  }
}


    // Normal run: DTR LOW, RTS HIGH->LOW pulse
    async function hardResetToApp() {
      if (!port) return;
      await port.open({ baudRate: BAUD }).catch(()=>{});
      try {
        await port.setSignals({ dataTerminalReady: true  }); // DTR LOW (hold)
        await port.setSignals({ requestToSend: false });     // RTS HIGH
        await sleep(40);
        await port.setSignals({ requestToSend: true  });     // RTS LOW pulse
        await sleep(120);
        await port.setSignals({ requestToSend: false });     // RTS HIGH
        await port.setSignals({ dataTerminalReady: false }); // DTR HIGH
        log('Normal reset (SparkFun run mode).');
      } catch(e) {
        log(`Reset failed: ${e?.message || e}`, true);
      } finally {
        try { await port.close(); } catch {}
      }
      await sleep(200);
    }

    async function disconnectClean() {
      try {
        try { await transport?.disconnect?.(); } catch {}
        try { await loader?.flashFinish?.(false); } catch {}
      } finally {
        try { await port?.setSignals?.({ dataTerminalReady: false, requestToSend: false }); } catch {}
        try { await port?.close?.(); } catch {}
        await sleep(150);
        loader = null; transport = null; port = null;

        connectBtn.disabled = false;
        flashBtn.disabled = true;
        resetBtn.disabled = true;
        disconnectBtn.disabled = true;

        log('Disconnected and port closed.');
        lastDisconnectAt = Date.now();
      }
    }
    disconnectBtn.onclick = disconnectClean;

    navigator.serial?.addEventListener?.('disconnect', async (e) => {
      if (port && e.target === port) {
        log('Device disconnected.');
        await disconnectClean();
      }
    });

    // --- Connect flow --------------------------------------------------------
    connectBtn.onclick = async () => {
      if (connecting) return;
      connecting = true;
      connectBtn.disabled = true;

      try {
        const since = Date.now() - lastDisconnectAt;
        if (since > 0 && since < RECONNECT_DELAY_MS) {
          await sleep(RECONNECT_DELAY_MS - since);
        }

        if (!('serial' in navigator)) {
          throw new Error('WebSerial not available. Use Chrome/Edge over HTTPS.');
        }

        await closeAllGrantedPorts();
        await sleep(100);

        try {
          port = await navigator.serial.requestPort({ filters: CH340_FILTERS });
        } catch (e) {
          if (String(e?.name) === 'NotFoundError') {
            port = await navigator.serial.requestPort({});
          } else {
            throw e;
          }
        }

        log('Port selected.');
        
        // Ensure closed (safety), then SparkFun bootloader entry via Transport
        try { await port.close(); } catch {}
        await sleep(100);
        await enterBootloaderSparkfun_viaTransport();   // <-- new helper above
        await sleep(120);

        // Build transport/loader
        transport = new Transport(port, false, false);


       
const loaderOptions = {
  transport,
  baudrate: BAUD,
  terminal: { clean(){ logEl.value=''; }, writeLine(s){ log(s); }, write(s){ log(s); } },

  // No-op reset strategies: esptool-js will call .reset(), so provide it
  resetConstructors: {
    classicReset: (t, delayMs) => ({ async reset(){ await sleep(delayMs ?? 100); } }),
    hardReset:   (t /*, usingUsbOtg */) => ({ async reset(){ /* no-op */ } }),
    usbJTAGSerialReset: (t) => ({ async reset(){ /* no-op */ } }),
    customReset: (t, seq) => ({ async reset(){ /* no-op */ } }),
  }
};

loader = new ESPLoader(loaderOptions);
try { loader.before = 'no_reset'; } catch {}


        // Make sure nothing is open before connect
        if (port.readable || port.writable) {
          try { await transport?.disconnect?.(); } catch {}
          try { await port.close(); } catch {}
          await sleep(150);
        }

        await loader.connect();  // should sync without library doing its own reset

        const chip = await loader.chip;
        log(`Connected (${chip})`);
        resetBtn.disabled = false;
        disconnectBtn.disabled = false;
        flashBtn.disabled = false;

      } catch (e) {
        log(`Connect failed: ${e?.name ? e.name+': ' : ''}${e?.message || e}`, true);

        try { await transport?.disconnect?.(); } catch {}
        try { await port?.setSignals?.({ dataTerminalReady: false, requestToSend: false }); } catch {}
        try { await port?.close(); } catch {}
        await sleep(150);

        flashBtn.disabled = true;
        resetBtn.disabled = true;
        disconnectBtn.disabled = true;
        connectBtn.disabled = false;
      } finally {
        connecting = false;
      }
    };

    // --- Flash flow (single image example) -----------------------------------
    flashBtn.onclick = async () => {
      flashBtn.disabled = true;
      try {
        const resp = await fetch('webflash/UTAudio.bin', { cache: 'no-cache' });
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const buf = new Uint8Array(await resp.arrayBuffer());
        log(`Image size: ${buf.length} bytes`);

        try {
          if (!loader.IS_STUB) {
            log('Running stub…');
            await (typeof loader.runStub === 'function' ? loader.runStub() : loader.loadStub());
            log('Stub ready.');
          } else {
            log('Stub already running — skipping stub load.');
          }
        } catch (e) {
          log(`Stub load failed: ${e?.message || e} (continuing)`, true);
        }

        await loader.eraseFlash();

        let bstr = '';
        for (let i = 0; i < buf.length; i++) bstr += String.fromCharCode(buf[i]);

        await loader.writeFlash({
          fileArray: [{ address: 0x000000, data: bstr }],
          flashSize: '16MB',
          flashMode: 'keep',
          flashFreq: 'keep',
          compress: true,
          reportProgress: (idx, written, total) => {
            if (total > 0) log(`Writing… ${Math.round((written/total)*100)}%`);
          }
        });

        log('Flash complete. Resetting…');
        await hardResetToApp();
        log('Done.');
        await disconnectClean();

      } catch (e) {
        log(`Flash failed: ${e?.message || e}`, true);
        flashBtn.disabled = false;
      }
    };

    resetBtn.onclick = async () => { await hardResetToApp(); };

    window.addEventListener('unload', () => {
      try { transport?.disconnect?.(); } catch {}
      try { port?.close?.(); } catch {}
    });

    
// DEBUG: try only the SparkFun reset without connecting
document.addEventListener('keydown', async (e) => {
  if (e.key === 'F8') { // press F8 for a manual SparkFun boot entry
    if (!port) {
      try {
        port = await navigator.serial.requestPort({ filters: CH340_FILTERS });
        log('Port selected (debug reset).');
      } catch { return; }
    }
    await enterBootloaderSparkfun_viaTransport();
    log('SparkFun boot-reset sequence sent.');
  }
});

    log('Installer script loaded.');
    connectBtn.disabled = !(Transport && ESPLoader);
  </script>
</body>
</html>
