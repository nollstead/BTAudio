
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>BTAudio Firmware Update</title>
  <style>
    :root{--bg:#121212;--panel:#1e1e1e;--text:#eaeaea;--muted:#bbb;--accent:#4CAF50;--accent2:#43a047;--border:rgba(255,255,255,.08)}
    *{box-sizing:border-box}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;max-width:780px;margin:48px auto;padding:20px;background:var(--bg);color:var(--text);line-height:1.6}
    h1{margin:0 0 8px}.muted{color:var(--muted)}
    .panel{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:20px;margin:18px 0;box-shadow:0 0 20px rgba(0,0,0,.35)}
    .row{display:flex;gap:12px;flex-wrap:wrap;margin:16px 0;align-items:center}
    .fw-label-row {flex-basis: 100%; margin-bottom: 6px;}
    .instructions{background:#1e1e1e;border-radius:14px;padding:18px;margin-top:10px}
    button{background:var(--accent);color:#fff;border:none;padding:12px 18px;border-radius:10px;font-weight:600;cursor:pointer}
    button[disabled]{opacity:.55;cursor:not-allowed}
    button:hover:not([disabled]){background:var(--accent2)}
    textarea{width:100%;height:260px;border-radius:8px;border:1px solid var(--border);background:#0f0f0f;color:#cfe8ff;padding:10px;font-family:ui-monospace,Menlo,Consolas,monospace}
    label{color:var(--muted)}

    /* Version picker styles */
    .fw-list{display:flex;flex-direction:column;gap:10px;margin-top:6px}
    .fw-item{display:flex;gap:12px;align-items:flex-start;padding:12px;border:1px solid var(--border);border-radius:10px;background:#141414}
    .fw-item input[type="radio"]{accent-color:#4CAF50;transform:scale(1.15);margin-top:2px}
    .fw-meta{display:flex;flex-direction:column;gap:2px}
    .fw-line{display:flex;gap:8px;flex-wrap:wrap}
    .fw-version{font-weight:700;color:#eaeaea}
    .fw-date{color:#ccc}
    .fw-label{color:#a6d5a6}
    .fw-notes{color:#bbb;font-size:0.95em}
  </style>
</head>
<body>
  <h1>BTAudio Firmware Update</h1>
  <p class="muted">v=7</p>

  <div class="panel">
    <div class="row">
      <button id="connectBtn" disabled>Connect</button>
      <button id="flashBtn"   disabled>Upload</button>
      <button id="disconnectBtn" disabled>Disconnect</button>
    </div>

<!-- Version picker (manifest-driven) -->
<div class="row" style="align-items:flex-start">
  <div class="fw-label-row">
    <label>Firmware Version</label>
  </div>

  <div id="fwList" class="fw-list">
    <div class="fw-item"><em class="muted">Loading versions…</em></div>
  </div>
</div>

    <div class="instructions">
      <h3>Instructions</h3>
      <ol>
        <li>Connect your BTAudio device to your computer via USB.</li>
        <li>Click <strong>Connect</strong> above and when prompted select the serial port (e.g., “USB‑SERIAL”).</li>
        <li>Click <strong>Upload</strong> and wait for completion.</li>
        <li>Your device will restart automatically once the upload is complete</li>
      </ol>
    </div>
  </div>

  <div class="panel">
    <h3>Log</h3>
    <textarea id="log" readonly></textarea>
  </div>

<script type="module">
  /********************************************************************
   * BTAudio Firmware Update – minimal index (manifest + connect shell)
   ********************************************************************/

  // Use the same version as test.html for identical behavior
  import * as esptool from 'https://unpkg.com/esptool-js@0.5.4/bundle.js';
  const { ESPLoader, Transport } = esptool;

  // ---------- Logging ----------
  const logEl = document.getElementById('log');
  function ts() { return new Date().toLocaleTimeString(); }
  function w(s){ logEl.value += `[${ts()}] ${s}\n`; logEl.scrollTop = logEl.scrollHeight; }
  const term = { clean(){}, writeLine(s){ if(s) w(`ESPLoader: ${s}`); }, write(s){ if(s) w(`ESPLoader: ${s}`); } };

  // ---------- DOM ----------
  const connectBtn = document.getElementById('connectBtn');
  const flashBtn   = document.getElementById('flashBtn');
  const disconnectBtn = document.getElementById('disconnectBtn');
  const fwList     = document.getElementById('fwList');

  // ---------- State & constants ----------
  let port=null, transport=null, loader=null, connected=false, stubReady=false;
  const OPEN_BAUD = 115200; // (FAST_BAUD not used yet; we’ll add when flashing is wired)
  const FILTERS = [
    { usbVendorId: 0x10c4 },                               // CP210x (LyraT)
    { usbVendorId: 0x1a86, usbProductId: 0x7523 },         // CH340C/G (SparkFun)
    { usbVendorId: 0x1a86, usbProductId: 0x5523 }          // CH340 alt PID (common on some clones)
  ];

  // Where the manifest is hosted
  const MANIFEST_URL  = 'https://nollstead.github.io/BTAudio/webflash/manifest.json';
  // Base used for relative part paths that live next to the manifest
  const MANIFEST_BASE = new URL('.', MANIFEST_URL).href;     // -> .../BTAudio/webflash/
  // Project base one level up (helps when parts already include `webflash/...`)
  const PROJECT_BASE  = new URL('..', MANIFEST_BASE).href;   // -> .../BTAudio/
  
  let chip = "default";
  let chipDesc = "default";
  const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));

  // Enable Connect when ESPLoader is present (matches test.html behavior)
  connectBtn.disabled = !(Transport && ESPLoader);

  // ---------- Manifest-driven picker ----------
  let manifest=null, selectedBuild=null;

  function parseSemver(v) {
    const m = String(v||'').trim().match(/^(\d+)\.(\d+)\.(\d+)$/);
    return m ? {maj:+m[1], min:+m[2], pat:+m[3]} : {maj:0, min:0, pat:0};
  }
  function compareSemverDesc(a, b) {
    const aa = parseSemver(a), bb = parseSemver(b);
    if (aa.maj !== bb.maj) return bb.maj - aa.maj;
    if (aa.min !== bb.min) return bb.min - aa.min;
    return bb.pat - aa.pat;
  }

  function renderFwList(builds){
    fwList.innerHTML = '';
    builds.forEach((b, idx) => {
      const id = `fw_${idx}`;
      const item = document.createElement('div');
      item.className = 'fw-item';

      const radio = document.createElement('input');
      radio.type = 'radio';
      radio.name = 'fwPick';
      radio.id = id;
      radio.value = b.version || '';
      radio.checked = (selectedBuild && selectedBuild.version === b.version) || (!selectedBuild && idx===0);
      radio.addEventListener('change', () => { selectedBuild = b; w(`UI: Selected build ${b.version} (${b.date||'no date'})`); });

      const meta = document.createElement('div');
      meta.className = 'fw-meta';

      const topLine = document.createElement('div');
      topLine.className = 'fw-line';
      const vSpan = document.createElement('span'); vSpan.className = 'fw-version'; vSpan.textContent = b.version || 'v?';
      topLine.appendChild(vSpan);
      if (b.date){
        const dSpan = document.createElement('span'); dSpan.className='fw-date'; dSpan.textContent = b.date;
        topLine.appendChild(dSpan);
      }
      if (b.label){
        const lSpan = document.createElement('span'); lSpan.className='fw-label'; lSpan.textContent = b.label;
        topLine.appendChild(lSpan);
      }

      meta.appendChild(topLine);

      if (b.notes){
        const n = document.createElement('div'); n.className='fw-notes'; n.textContent = b.notes;
        meta.appendChild(n);
      }

      item.appendChild(radio);
      item.appendChild(meta);
      fwList.appendChild(item);

      if (!selectedBuild && radio.checked) selectedBuild = b;
    });
  }

  async function loadManifest() {

    w(`Manifest: fetching ${MANIFEST_URL} …`);
    const resp = await fetch(MANIFEST_URL, { cache: 'no-cache' });
    w(`Manifest: HTTP status ${resp.status}`);
    if (!resp.ok) throw new Error(`manifest HTTP ${resp.status}`);
    const data = await resp.json();
    if (!Array.isArray(data.builds)) throw new Error('manifest: builds missing');
    data.builds.sort((a,b) => {
      const sv = compareSemverDesc(a.version||'0.0.0', b.version||'0.0.0');
      if (sv !== 0) return sv;
      return String(b.date||'').localeCompare(String(a.date||''));
    });
    manifest = data;
    selectedBuild = null;
    renderFwList(data.builds);
    w(`Manifest: loaded ${data.builds.length} build(s); newest = ${data.builds[0]?.version||'n/a'}`);

    // Keep Upload disabled until Connect succeeds
    flashBtn.disabled = true;
  }

  loadManifest().catch(e => {
    fwList.innerHTML = '';
    const fallback = {
      version: 'current',
      chipFamily: 'ESP32',
      parts: [{ path: `${MANIFEST_BASE}BTAudio.bin`, offset: 0 }]
    };
    selectedBuild = fallback;
    const div = document.createElement('div');
    div.className='fw-item';
    div.innerHTML = `<input type="radio" name="fwPick" checked style="margin-top:2px">
                     <div class="fw-meta">
                       <div class="fw-line">
                         <span class="fw-version">current</span>
                         <span class="fw-date">manifest unavailable</span>
                       </div>
                       <div class="fw-notes">Using default BTAudio.bin</div>
                     </div>`;
    fwList.appendChild(div);
    w(`Manifest: load failed (${e?.message||e}). Using fallback image.`);

    // Keep Upload disabled until Connect succeeds
    flashBtn.disabled = true;
  });


// Convert Uint8Array -> binary string (some bundles still expect a string in writeFlash)
function u8ToBinaryString(u8) {
  let s = '';
  const CHUNK = 1 << 15; // 32KB
  for (let i = 0; i < u8.length; i += CHUNK) {
    s += String.fromCharCode.apply(null, u8.subarray(i, i + CHUNK));
  }
  return s;
}

// ---------- Connect ----------
connectBtn.onclick = async () => {
  connectBtn.disabled = true;
  try {
    if (!('serial' in navigator)) throw new Error('Web Serial not available (use Chrome/Edge over HTTPS).');
    w(`ENV: UA=${navigator.userAgent}`);

    // Let user pick a port (shows both CP210x + CH340 because of your FILTERS)
    port = await navigator.serial.requestPort({ filters: FILTERS });
    const info = port.getInfo?.()||{};
    const vendorId  = info.usbVendorId  || 0;
    const productId = info.usbProductId || 0;

    w(`CONNECT: Selected port -> VID=0x${vendorId.toString(16)} PID=0x${productId.toString(16)}`);
    transport = new Transport(port,  false, false);
    loader = new ESPLoader({ transport, baudrate: OPEN_BAUD, terminal: term });
    connected = true;
    chipDesc = await loader.main();
    w(`Chip description: ${chipDesc}`);
    chip = loader.chip?.CHIP_NAME;    
    w(`Chip: ${chip}`);
    await loader.flashId();
    w(`after esploader.flashId`)
      flashBtn.disabled = false;
    disconnectBtn.disabled = false;
  } catch (e) {
    w(`CONNECT: FAILED: ${e?.name?e.name+': ':''}${e?.message || e}`);
    try { await port?.close?.(); } catch {}
    transport = loader = null;
    connectBtn.disabled = false;
  }
};

    

// ---------- Disconnect (Launchpad-style reset via DTR pulse) ----------
disconnectBtn.onclick = async () => {
  w('DISCONNECT: Begin (Launchpad-style DTR reset) …');

  // tiny inline nap so we don't add helpers
  const nap = (ms) => new Promise(r => setTimeout(r, ms));

  try {
    // 1) If esptool-js has the port, disconnect so native setSignals can take over.
    if (transport) {
      try {
        await transport.disconnect();
        w('DISCONNECT: transport.disconnect() OK');
      } catch (e) {
        w(`DISCONNECT: transport.disconnect() err: ${e?.message || e}`);
      }
    }

    // 2) Open native WebSerial port and issue a pure-DTR reset pulse (EN low→high).
    try { await port?.close?.(); } catch {} // defensive

    await port.open({ baudRate: OPEN_BAUD });
    w('DISCONNECT: port.open() OK');

    // DTR = true  → EN LOW (assert reset)
    await port.setSignals({ dataTerminalReady: true });
    w('DISCONNECT: DTR=true (EN LOW)');
    await nap(120); // 100–200 ms is sufficient

    // DTR = false → EN HIGH (release reset) -> device boots your app
    await port.setSignals({ dataTerminalReady: false });
    w('DISCONNECT: DTR=false (EN HIGH -> run app)');

    // Small settle; then close
    await nap(120);
    await port.close();
    w('DISCONNECT: port.close() OK');

  } catch (e) {
    w(`DISCONNECT: Error: ${e?.message || e}`);
  } finally {
    // 3) Reset state / UI exactly like your connect handler expects.
    port = transport = loader = null;
    connected = false;
    connectBtn.disabled = false;
    flashBtn.disabled = true;
    disconnectBtn.disabled = true;
    w('DISCONNECT: Completed.');
  }
};
  
// ---------- Upload (Flash) ----------
flashBtn.onclick = async () => {
  flashBtn.disabled = true;
  try {
    if (!selectedBuild) throw new Error('No firmware selected.');
    if (!loader || !transport) throw new Error('Not connected. Click Connect first.');

    // Build parts from manifest. Expect: { parts: [{ path, offset }], chipFamily: 'ESP32' }
    // Fallback if manifest omitted: a single merged image at 0x000000
    const parts = Array.isArray(selectedBuild.parts) && selectedBuild.parts.length
      ? selectedBuild.parts
      : [{ path: 'webflash/BTAudio.bin', offset: 0 }];

    // Normalize offsets to numbers (hex or decimal accepted)
    const fileArray = [];
    let totalBytes = 0;

    w(`FLASH: Preparing ${parts.length} part(s) …`);
    for (const p of parts) {
      // Resolve firmware part URLs robustly:
      // - absolute http(s): use as-is
      // - leading '/': resolve against origin
      // - starts with 'webflash/': resolve from project base (.../BTAudio/)
      // - otherwise: resolve from manifest dir (.../BTAudio/webflash/)
      let url;
      if (/^https?:\/\//i.test(p.path)) {
        url = p.path;
      } else if (p.path.startsWith('/')) {
        url = new URL(p.path, window.location.origin).href;
      } else if (p.path.startsWith('webflash/')) {
        url = new URL(p.path, PROJECT_BASE).href;
      } else {
        url = new URL(p.path, MANIFEST_BASE).href;
      }
      w(`FLASH: Fetching ${url}`);
      const resp = await fetch(url, { cache: 'no-cache' });
      if (!resp.ok) throw new Error(`HTTP ${resp.status} for ${url}`);
      const u8 = new Uint8Array(await resp.arrayBuffer());
      totalBytes += u8.length;
      fileArray.push({
        address: (typeof p.offset === 'string' && p.offset.startsWith('0x')) ? parseInt(p.offset, 16)
               : (typeof p.offset === 'number' ? p.offset
               : parseInt(p.offset || 0, 10)),
        data: u8ToBinaryString(u8)
      });
      w(`FLASH: queued ${u8.length} bytes @ 0x${fileArray[fileArray.length-1].address.toString(16)}`);
    }

    // Show our own progress
    let lastPct = -1;
    const reportProgress = (_idx, written, total) => {
      const pct = total > 0 ? Math.floor((written / total) * 100) : 0;
      if (pct !== lastPct) { lastPct = pct; w(`FLASH: ${pct}%`); }
    };

    // Minimal call: keep flash parameters; compress true for speed; stay @115200 for CH340 reliability
    w(`FLASH: Writing ${totalBytes} bytes (compressed) …`);
    await loader.writeFlash({
      fileArray,
      flashSize: 'keep',
      flashMode: 'keep',
      flashFreq: 'keep',
      compress: true,
      reportProgress
    });
    w('FLASH: Write complete.');

    // Finish & reboot
    w('FLASH: Finalizing & rebooting …');
    try {
      await loader.flashFinish(true); // true => reset to run app
      w('FLASH: flashFinish(true) OK');
    } catch (e) {
      w(`FLASH: flashFinish(true) err: ${e?.message || e}`);
    }

    // Optional: brief settle
    await sleep(150);
    w('DONE: Upload finished. Device should reboot into the new firmware.');

  } catch (e) {
    w(`FLASH: FAILED: ${e?.message || e}`);
  } finally {
    // Leave connected state as-is so the user can Disconnect or Upload again if desired
    flashBtn.disabled = false;
  }
};

</script>
</body>
</html>
