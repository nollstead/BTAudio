<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>BTAudio Connect Test</title>
  <style>
    :root{--bg:#121212;--panel:#1e1e1e;--text:#eaeaea;--muted:#bbb;--accent:#4CAF50;--accent2:#43a047;--border:rgba(255,255,255,.08)}
    *{box-sizing:border-box}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;max-width:820px;margin:36px auto;padding:20px;background:var(--bg);color:var(--text)}
    h1{margin:0 0 6px} .muted{color:var(--muted)}
    .panel{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:18px;margin:16px 0}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    button{background:var(--accent);color:#fff;border:none;padding:10px 14px;border-radius:8px;font-weight:600;cursor:pointer}
    button[disabled]{opacity:.55;cursor:not-allowed}
    button:hover:not([disabled]){background:var(--accent2)}
    textarea{width:100%;height:360px;border-radius:8px;border:1px solid var(--border);background:#0f0f0f;color:#cfe8ff;padding:10px;font-family:ui-monospace,Menlo,Consolas,monospace}
    code{background:#0f0f0f;padding:2px 6px;border-radius:6px;border:1px solid var(--border)}
  </style>
</head>
<body>
  <h1>BTAudio Connect Test</h1>
  <p class="muted">Only what we need: <strong>Connect</strong> → <strong>Flash</strong>. Extra logging everywhere.</p>

  <div class="panel">
    <div class="row">
      <button id="btnConnect"  disabled>Connect</button>
      <button id="btnFlash"    disabled>Flash</button>
      <button id="btnDisconnect" disabled>Disconnect</button>
    </div>
    <div class="muted" style="margin-top:6px">
      Binary: <code id="binUrlLabel">https://nollstead.github.io/BTAudio/webflash/BTAudio.bin</code> @ <code>0x000000</code>
    </div>
  </div>

  <div class="panel">
    <h3>Log</h3>
    <textarea id="log" readonly></textarea>
  </div>

  <!-- esptool-js -->
  <script type="module">
    import * as esptool from 'https://unpkg.com/esptool-js@0.5.4/bundle.js';
    const { ESPLoader, Transport } = esptool;

    // -------- Config (edit as needed) ----------
    const OPEN_BAUD    = 115200;   // initial connect baud
    const FAST_BAUD    = 921600;   // after stub
    const ERASE_FIRST  = true;     // set to false to skip erase
    const BIN_URL      = 'https://nollstead.github.io/BTAudio/webflash/BTAudio.bin';
    const BIN_ADDRESS  = 0x000000; // merged image at 0x0
    const FILTERS = [
      { usbVendorId: 0x10c4 },                      // CP210x (LyraT)
      { usbVendorId: 0x1a86, usbProductId: 0x7523 } // CH340C (SparkFun)
    ];
    let chip = "default";
    let chipDesc = "default";

    // ---------- Logging ----------
    const logEl = document.getElementById('log');
    const w = (s)=>{ logEl.value += `[${new Date().toLocaleTimeString()}] ${s}\n`; logEl.scrollTop = logEl.scrollHeight; };
    const term = { clean(){}, writeLine(s){ if(s) w(`ESPLoader: ${s}`); }, write(s){ if(s) w(`ESPLoader: ${s}`); } };

    // ---------- DOM ----------
    const btnConnect    = document.getElementById('btnConnect');
    const btnFlash      = document.getElementById('btnFlash');
    const btnDisconnect = document.getElementById('btnDisconnect');
    document.getElementById('binUrlLabel').textContent = BIN_URL;

    // ---------- State ----------
    let port=null, transport=null, loader=null, connected=false, stubReady=false;

    // ---------- Helpers ----------
    const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));

    
// Convert Uint8Array -> binary string (compatible with browser bundles that
// still call .charCodeAt() internally during writeFlash)
function u8ToBinaryString(u8) {
  let s = '';
  const CHUNK = 1 << 15; // 32 KB
  for (let i = 0; i < u8.length; i += CHUNK) {
    s += String.fromCharCode.apply(null, u8.subarray(i, i + CHUNK));
  }
  return s;
}

// ---------- Connect ----------
btnConnect.onclick = async () => {
  btnConnect.disabled = true;
  try {
    if (!('serial' in navigator)) throw new Error('Web Serial not available (use Chrome/Edge over HTTPS).');
    w(`ENV: UA=${navigator.userAgent}`);

    // Let user pick a port (shows both CP210x + CH340 because of your FILTERS)
    port = await navigator.serial.requestPort({ filters: FILTERS });
    const info = port.getInfo?.()||{};
    const vendorId  = info.usbVendorId  || 0;
    const productId = info.usbProductId || 0;

    w(`CONNECT: Selected port -> VID=0x${vendorId.toString(16)} PID=0x${productId.toString(16)}`);
    transport = new Transport(port,  false, false);
    loader = new ESPLoader({ transport, baudrate: OPEN_BAUD, terminal: term });
    w('loader loaded')
    connected = true;
    chipDesc = await loader.main();
    w(`Chip description: ${chipDesc}`);
    chip = loader.chip?.CHIP_NAME;    
    w(`Chip: ${chip}`);
    await loader.flashId();
    w('after esploader.flashId')          
    btnDisconnect.disabled = !connected;        
  } catch (e) {
    w(`CONNECT: FAILED: ${e?.name?e.name+': ':''}${e?.message || e}`);
    try { await port?.close?.(); } catch {}
    btnConnect.disabled = false;
  }
};

    

// ---------- Disconnect (Launchpad-style reset via DTR pulse) ----------
btnDisconnect.onclick = async () => {
  w('DISCONNECT: Begin (Launchpad-style DTR reset) …');

  // tiny inline nap so we don't add helpers
  const nap = (ms) => new Promise(r => setTimeout(r, ms));

  try {
    // 1) If esptool-js has the port, disconnect so native setSignals can take over.
    if (transport) {
      try {
        await transport.disconnect();
        w('DISCONNECT: transport.disconnect() OK');
      } catch (e) {
        w(`DISCONNECT: transport.disconnect() err: ${e?.message || e}`);
      }
    }

    // 2) Open native WebSerial port and issue a pure-DTR reset pulse (EN low→high).
    try { await port?.close?.(); } catch {} // defensive

    await port.open({ baudRate: OPEN_BAUD });
    w('DISCONNECT: port.open() OK');

    // DTR = true  → EN LOW (assert reset)
    await port.setSignals({ dataTerminalReady: true });
    w('DISCONNECT: DTR=true (EN LOW)');
    await nap(120); // 100–200 ms is sufficient

    // DTR = false → EN HIGH (release reset) -> device boots your app
    await port.setSignals({ dataTerminalReady: false });
    w('DISCONNECT: DTR=false (EN HIGH -> run app)');

    // Small settle; then close
    await nap(120);
    await port.close();
    w('DISCONNECT: port.close() OK');

  } catch (e) {
    w(`DISCONNECT: Error: ${e?.message || e}`);
  } finally {
    // 3) Reset state / UI exactly like your connect handler expects.
    port = transport = loader = null;
    connected = false;
    btnConnect.disabled = false;
    btnDisconnect.disabled = true;
    w('DISCONNECT: Completed.');
  }
};


    // ---------- On unload ----------
    window.addEventListener('unload',()=>{
      try{ transport?.disconnect?.(); }catch{}
      try{ port?.close?.(); }catch{}
    });

    // Enable Connect when ESPLoader is present
    btnConnect.disabled = !(Transport && ESPLoader);
    w('READY: Minimal test loaded. Click Connect, then Flash.');
  </script>
</body>
</html>
