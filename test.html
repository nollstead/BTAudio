
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>BTAudio – Serial Reset Test (LyraT/CP2102N)</title>
  <style>
    :root{--bg:#121212;--panel:#1e1e1e;--text:#eaeaea;--muted:#bbb;--accent:#4CAF50;--accent2:#43a047;--border:rgba(255,255,255,.08)}
    *{box-sizing:border-box}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;max-width:820px;margin:36px auto;padding:20px;background:var(--bg);color:var(--text)}
    h1{margin:0 0 6px} .muted{color:var(--muted)}
    .panel{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:18px;margin:16px 0}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    button{background:var(--accent);color:#fff;border:none;padding:10px 14px;border-radius:8px;font-weight:600;cursor:pointer}
    button[disabled]{opacity:.55;cursor:not-allowed}
    button:hover:not([disabled]){background:var(--accent2)}
    textarea{width:100%;height:340px;border-radius:8px;border:1px solid var(--border);background:#0f0f0f;color:#cfe8ff;padding:10px;font-family:ui-monospace,Menlo,Consolas,monospace}
    code{background:#0f0f0f;padding:2px 6px;border-radius:6px;border:1px solid var(--border)}
  </style>
</head>
<body>
  <h1>BTAudio – Serial Reset Test v3</h1>
  <p class="muted">Purpose: validate **open → enter bootloader → esptool connect → run app → disconnect** using CP2102N (LyraT v4.3).</p>

  <div class="panel">
    <div class="row">
      <button id="btnOpen">Open &amp; Select Port</button>
      <button id="btnBoot" disabled>Enter Bootloader (DTR/RTS)</button>
      <button id="btnConnect" disabled>Connect (esptool‑js)</button>
      <button id="btnRun" disabled>Run App (EN pulse)</button>
      <button id="btnClose" disabled>Disconnect &amp; Close</button>
    </div>
    <p class="muted" style="margin-top:6px">
      Tips:
      <br/>• Use Chrome/Edge over HTTPS (Web Serial requirement).
      <br/>• Ensure no other serial app is holding the port.
      <br/>• If first connect fails, repeat the sequence: <code>Enter Bootloader → Connect</code>.
    </p>
  </div>

  <div class="panel">
    <h3>Log</h3>
    <textarea id="log" readonly></textarea>
  </div>


<script type="module">
  /********************************************************************
   * BTAudio – Serial Reset Test (LyraT/CP2102N)
   * Goal: Temporarily open for DTR/RTS (signals), then close; let
   *       esptool-js manage open during connect(). Ultra-verbose logs.
   ********************************************************************/

  import * as esptool from 'https://unpkg.com/esptool-js@0.5.7/bundle.js';
  const { ESPLoader, Transport } = esptool;

  // ---------- Logging ----------
  const logEl = document.getElementById('log');
  const w = (s)=>{ logEl.value += `[${new Date().toLocaleTimeString()}] ${s}\n`; logEl.scrollTop = logEl.scrollHeight; };
  const term = { clean(){}, writeLine(s){ if(s) w(`ESPLoader: ${s}`); }, write(s){ if(s) w(`ESPLoader: ${s}`); } };

  // ---------- DOM ----------
  const btnOpen    = document.getElementById('btnOpen');
  const btnBoot    = document.getElementById('btnBoot');
  const btnConnect = document.getElementById('btnConnect');
  const btnRun     = document.getElementById('btnRun');
  const btnClose   = document.getElementById('btnClose');

  // ---------- State ----------
  let port=null, transport=null, loader=null;
  const OPEN_BAUD = 115200;
  const FAST_BAUD = 921600;
  const FILTERS = [{ usbVendorId: 0x10c4 }]; // CP210x (LyraT). Add CH340C if needed: {usbVendorId:0x1a86, usbProductId:0x7523}
  const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));

  // ---------- Low-level: temporarily open native port for signals ----------
  async function withOpenPort(fn, label='SIG') {
    if (!port) throw new Error('No port selected.');
    // If the page crashed earlier, port may already be open; try close first.
    try { await port.close(); } catch {}
    try {
      await port.open({ baudRate: OPEN_BAUD });
      w(`${label}: port.open({ baudRate: ${OPEN_BAUD} }) OK`);
    } catch (e) {
      w(`${label}: port.open() FAILED: ${e?.message||e}`);
      throw e;
    }
    try {
      await fn();
    } finally {
      try { await port.close(); w(`${label}: port.close() OK`); } 
      catch(e) { w(`${label}: port.close() err: ${e?.message||e}`); }
    }
  }

  async function setSignals(dtr, rts, label='SIG') {
    try { await port.setSignals({ dataTerminalReady: !!dtr, requestToSend: !!rts }); 
          w(`${label}: setSignals(DTR=${!!dtr}, RTS=${!!rts}) OK`); }
    catch(e){ w(`${label}: setSignals(DTR=${!!dtr}, RTS=${!!rts}) FAIL: ${e?.message||e}`); }
  }

  // ---------- Enter Bootloader (GPIO0 LOW @ EN rising) ----------
  async function enterBootloader() {
    w('BOOTFLOW: Begin (GPIO0 LOW at EN rising) …');
    await withOpenPort(async () => {
      // Neutral (idle high)
      await setSignals(false, false, 'BOOTFLOW'); // GPIO0 HIGH, EN HIGH
      await sleep(20);

      // Hold BOOT (GPIO0 LOW)
      await setSignals(true, false, 'BOOTFLOW');  // DTR=true
      await sleep(40);

      // EN pulse (active-low)
      await setSignals(true, true, 'BOOTFLOW');   // EN LOW
      await sleep(150);
      await setSignals(true, false, 'BOOTFLOW');  // EN HIGH -> ROM samples GPIO0 LOW
      w('BOOTFLOW: EN rising occurred with GPIO0 LOW (device should be in ROM loader).');

      // Release BOOT so a later reset can run app
      await sleep(120);
      await setSignals(false, false, 'BOOTFLOW'); // GPIO0 HIGH, EN HIGH
      await sleep(60);
    }, 'BOOTFLOW');
    w('BOOTFLOW: Completed.');
  }

  // ---------- Run App (GPIO0 HIGH @ EN rising) ----------
  async function runApp() {
    w('RUNFLOW: Begin (GPIO0 HIGH at EN rising) …');
    await withOpenPort(async () => {
      // Ensure BOOT released, then pulse EN
      await setSignals(false, false, 'RUNFLOW'); // idle
      await setSignals(false, true , 'RUNFLOW'); // EN LOW
      await sleep(150);
      await setSignals(false, false, 'RUNFLOW'); // EN HIGH -> run app
      await sleep(180);
    }, 'RUNFLOW');
    w('RUNFLOW: Completed.');
  }

  // ---------- Button: Open & Select Port ----------
  btnOpen.onclick = async () => {
    try {
      if (!('serial' in navigator)) throw new Error('Web Serial not available (use Chrome/Edge over HTTPS).');
      w(`ENV: UA=${navigator.userAgent}`);

      port = await navigator.serial.requestPort({ filters: FILTERS });
      const info = port.getInfo?.()||{};
      w(`OPEN: Selected port -> VID=0x${(info.usbVendorId||0).toString(16)} PID=0x${(info.usbProductId||0).toString(16)}`);

      // Do NOT keep port open. We'll open/close around signals, and let esptool-js open during connect.
      transport = null; loader = null;

      btnBoot.disabled = false;
      btnConnect.disabled = false;
      btnRun.disabled = false;
      btnClose.disabled = false;
      btnOpen.disabled = true;

    } catch (e) {
      w(`OPEN: FAILED: ${e?.message||e}`);
    }
  };

  // ---------- Button: Enter Bootloader ----------
  btnBoot.onclick = async () => {
    if (!port) { w('BOOT: port not selected.'); return; }
    await enterBootloader();
  };

  // ---------- Button: Connect (esptool-js) with guarded retry ----------
  btnConnect.onclick = async () => {
    if (!port) { w('CONNECT: port not selected.'); return; }

    // Build Transport/Loader with port CLOSED; allow esptool-js to manage open
    try { await port.close(); } catch {}
    transport = new Transport(port, false, false);
    loader = new ESPLoader({ transport, baudrate: OPEN_BAUD, terminal: term });

    // Attempt 1
    try {
      w('CONNECT: Short settle before ESPLoader.connect() …');
      await sleep(60);
      w('CONNECT: Calling ESPLoader.connect() (attempt 1) …');
      await loader.connect();                // esptool-js will open/sync/close as needed internally
      w('CONNECT: SUCCESS (attempt 1)');
      return;
    } catch (e) {
      w(`CONNECT: attempt 1 FAILED: ${e?.message||e}`);
    }

    // Retry once with stronger boot pulse, then connect again
    try {
      w('CONNECT: Retrying with stronger boot pulse …');
      await withOpenPort(async () => {
        await setSignals(false, false, 'RETRY');
        await sleep(40);
        await setSignals(true , false, 'RETRY'); // GPIO0 LOW
        await sleep(60);
        await setSignals(true , true , 'RETRY'); // EN LOW
        await sleep(200);
        await setSignals(true , false, 'RETRY'); // EN HIGH -> ROM loader
        w('BOOTFLOW: (retry) EN rising with GPIO0 LOW');
        await sleep(150);
        await setSignals(false, false, 'RETRY'); // release BOOT
        await sleep(80);
      }, 'RETRY');

      w('CONNECT: Calling ESPLoader.connect() (attempt 2) …');
      await loader.connect();
      w('CONNECT: SUCCESS (attempt 2)');
    } catch (e2) {
      w(`CONNECT: attempt 2 FAILED: ${e2?.message||e2}`);
    }
  };

  // ---------- Button: Run App ----------
  btnRun.onclick = async () => {
    if (!port) { w('RUN: port not selected.'); return; }
    await runApp();
  };

  // ---------- Button: Disconnect & Close ----------
  btnClose.onclick = async () => {
    w('CLOSE: Begin cleanup …');
    try { await transport?.disconnect?.(); w('CLOSE: transport.disconnect() OK'); } catch(e){ w(`CLOSE: transport.disconnect() err: ${e?.message||e}`); }
    try { await loader?.flashFinish?.(false); w('CLOSE: loader.flashFinish(false) OK'); } catch(e){ w(`CLOSE: flashFinish(false) err: ${e?.message||e}`); }
    try { await port?.close?.(); w('CLOSE: port.close() OK'); } catch(e){ w(`CLOSE: port.close() err: ${e?.message||e}`); }
    port=transport=loader=null;
    btnOpen.disabled=false; btnBoot.disabled=true; btnConnect.disabled=true; btnRun.disabled=true; btnClose.disabled=true;
    w('CLOSE: Completed.');
  };

  // ---------- On unload ----------
  window.addEventListener('unload',()=>{
    try{ transport?.disconnect?.(); }catch{}
    try{ port?.close?.(); }catch{}
  });

  w('READY: Test page loaded. 1) Open & Select Port → 2) Enter Bootloader → 3) Connect → 4) Run App → 5) Disconnect.');
</script>

</body>
</html>
