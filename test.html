<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>BTAudio – Serial Reset Test (LyraT/CP2102N)</title>
  <style>
    :root{--bg:#121212;--panel:#1e1e1e;--text:#eaeaea;--muted:#bbb;--accent:#4CAF50;--accent2:#43a047;--border:rgba(255,255,255,.08)}
    *{box-sizing:border-box}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;max-width:820px;margin:36px auto;padding:20px;background:var(--bg);color:var(--text)}
    h1{margin:0 0 6px} .muted{color:var(--muted)}
    .panel{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:18px;margin:16px 0}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    button{background:var(--accent);color:#fff;border:none;padding:10px 14px;border-radius:8px;font-weight:600;cursor:pointer}
    button[disabled]{opacity:.55;cursor:not-allowed}
    button:hover:not([disabled]){background:var(--accent2)}
    textarea{width:100%;height:340px;border-radius:8px;border:1px solid var(--border);background:#0f0f0f;color:#cfe8ff;padding:10px;font-family:ui-monospace,Menlo,Consolas,monospace}
    code{background:#0f0f0f;padding:2px 6px;border-radius:6px;border:1px solid var(--border)}
  </style>
</head>
<body>
  <h1>BTAudio – Serial Reset Test v3</h1>
  <p class="muted">Purpose: validate **open → enter bootloader → esptool connect → run app → disconnect** using CP2102N (LyraT v4.3).</p>

  <div class="panel">
    <div class="row">
      <button id="btnOpen">Open &amp; Select Port</button>
      <button id="btnBoot" disabled>Enter Bootloader (DTR/RTS)</button>
      <button id="btnConnect" disabled>Connect (esptool‑js)</button>
      <button id="btnRun" disabled>Run App (EN pulse)</button>
      <button id="btnClose" disabled>Disconnect &amp; Close</button>
    </div>
    <p class="muted" style="margin-top:6px">
      Tips:
      <br/>• Use Chrome/Edge over HTTPS (Web Serial requirement).
      <br/>• Ensure no other serial app is holding the port.
      <br/>• If first connect fails, repeat the sequence: <code>Enter Bootloader → Connect</code>.
    </p>
  </div>

  <div class="panel">
    <h3>Log</h3>
    <textarea id="log" readonly></textarea>
  </div>


<script type="module">
  /********************************************************************
   * BTAudio – Serial Reset Test with Mapping Toggle (LyraT/CP2102N)
   *
   * Purpose: Validate BOOT/EN control using either mapping:
   *   Mapping A: DTR -> GPIO0 (BOOT), RTS -> EN     (active-low)
   *   Mapping B: DTR -> EN,              RTS -> GPIO0 (active-low)
   *
   * Flow:
   *   1) Open & Select Port (does NOT keep port open)
   *   2) Enter Bootloader  (temp open -> setSignals -> close)
   *   3) Connect (esptool-js manages its own open/close)
   *   4) Run App          (temp open -> setSignals -> close)
   *   5) Disconnect & Close
   *
   * Super-verbose logs show every signals change and outcome.
   ********************************************************************/

  import * as esptool from 'https://unpkg.com/esptool-js@0.5.7/bundle.js';
  const { ESPLoader, Transport } = esptool;

  // ---------- Logging ----------
  const logEl = document.getElementById('log');
  const w = (s)=>{ logEl.value += `[${new Date().toLocaleTimeString()}] ${s}\n`; logEl.scrollTop = logEl.scrollHeight; };
  const term = { clean(){}, writeLine(s){ if(s) w(`ESPLoader: ${s}`); }, write(s){ if(s) w(`ESPLoader: ${s}`); } };

  // ---------- DOM (we add a mapping toggle dynamically) ----------
  const btnOpen    = document.getElementById('btnOpen');
  const btnBoot    = document.getElementById('btnBoot');
  const btnConnect = document.getElementById('btnConnect');
  const btnRun     = document.getElementById('btnRun');
  const btnClose   = document.getElementById('btnClose');

  // Add mapping UI
  const mappingRow = document.createElement('div');
  mappingRow.style.cssText = 'margin:8px 0 0 0; display:flex; align-items:center; gap:10px;';
  mappingRow.innerHTML = `
    <label style="color:#bbb">Control-line mapping:</label>
    <select id="mapSel" style="padding:6px 8px; border-radius:8px; background:#0f0f0f; color:#eaeaea; border:1px solid rgba(255,255,255,.08)">
      <option value="A">A: DTR→GPIO0 (BOOT), RTS→EN (default)</option>
      <option value="B">B: DTR→EN, RTS→GPIO0</option>
    </select>
  `;
  btnOpen.parentElement.parentElement.appendChild(mappingRow);
  const mapSel = mappingRow.querySelector('#mapSel');

  // ---------- State ----------
  let port=null, transport=null, loader=null;
  const OPEN_BAUD = 115200;
  const FAST_BAUD = 921600;
  const FILTERS = [{ usbVendorId: 0x10c4 }]; // CP210x (LyraT)
  const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));

  // ---------- Mappings ----------
  // We do all low-level work with native SerialPort.setSignals via temporary open/close.
  function activeMapping() { return mapSel.value || 'A'; }

  // In mapping A: BOOT=DTR, EN=RTS; mapping B: BOOT=RTS, EN=DTR
  function lineFor(name){ // name: 'BOOT' or 'EN'
    const m = activeMapping();
    if (m === 'A') return (name === 'BOOT') ? 'DTR' : 'RTS';
    else           return (name === 'BOOT') ? 'RTS' : 'DTR';
  }

  // Log the current mapping
  function logMapping(prefix='MAP'){
    const m = activeMapping();
    if (m === 'A') w(`${prefix}: Using Mapping A — DTR→GPIO0(BOOT), RTS→EN (active-low)`);
    else           w(`${prefix}: Using Mapping B — DTR→EN, RTS→GPIO0(BOOT) (active-low)`);
  }

  // ---------- Low-level: temporarily open native port for signals ----------
  async function withOpenPort(fn, label='SIG') {
    if (!port) throw new Error('No port selected.');
    try { await port.close(); } catch {}
    try {
      await port.open({ baudRate: OPEN_BAUD });
      w(`${label}: port.open({ baudRate: ${OPEN_BAUD} }) OK`);
    } catch (e) {
      w(`${label}: port.open() FAILED: ${e?.message||e}`);
      throw e;
    }
    try {
      await fn();
    } finally {
      try { await port.close(); w(`${label}: port.close() OK`); }
      catch(e) { w(`${label}: port.close() err: ${e?.message||e}`); }
    }
  }

  async function setSignalsRaw(dtr, rts, label='SIG') {
    try {
      await port.setSignals({ dataTerminalReady: !!dtr, requestToSend: !!rts });
      w(`${label}: setSignals(DTR=${!!dtr}, RTS=${!!rts}) OK`);
    } catch(e) {
      w(`${label}: setSignals(DTR=${!!dtr}, RTS=${!!rts}) FAIL: ${e?.message||e}`);
    }
  }

  // Handy wrappers that honor the mapping: set BOOT/EN individually (booleans are "active" levels)
  async function setBOOT(active, label){ // active=true => pull GPIO0 low (active-low)
    const BOOT = lineFor('BOOT'); // 'DTR' or 'RTS'
    if (BOOT === 'DTR') return setSignalsRaw(active, undefined, label); // we'll call combined setter below, so use convenience combiner
    else                return setSignalsRaw(undefined, active, label);
  }
  async function setEN(active, label){   // active=true => pull EN low (reset asserted)
    const EN = lineFor('EN');   // 'DTR' or 'RTS'
    if (EN === 'DTR') return setSignalsRaw(active, undefined, label);
    else              return setSignalsRaw(undefined, active, label);
  }

  // Combined helper to set both BOOT & EN respecting mapping
  async function setBOOT_EN(bootActive, enActive, label='SIG'){
    const BOOT = lineFor('BOOT'), EN = lineFor('EN');
    let dtr = undefined, rts = undefined;

    if (BOOT === 'DTR') dtr = bootActive; else rts = bootActive;
    if (EN   === 'DTR') dtr = enActive;   else rts = enActive;

    try {
      await port.setSignals({
        dataTerminalReady: (dtr !== undefined) ? !!dtr : undefined,
        requestToSend:     (rts !== undefined) ? !!rts : undefined
      });
      w(`${label}: setBOOT_EN(BOOT=${!!bootActive}, EN=${!!enActive}) -> (DTR=${dtr===undefined?'(no change)':!!dtr}, RTS=${rts===undefined?'(no change)':!!rts}) OK`);
    } catch(e) {
      w(`${label}: setBOOT_EN FAIL: ${e?.message||e}`);
    }
  }

  // ---------- Enter Bootloader (GPIO0 LOW @ EN rising) ----------
  async function enterBootloader() {
    logMapping('BOOTFLOW');
    w('BOOTFLOW: Begin (GPIO0 LOW at EN rising) …');
    await withOpenPort(async () => {
      // Neutral (BOOT released, EN high) => BOOT=false, EN=false
      await setBOOT_EN(false, false, 'BOOTFLOW'); // GPIO0 HIGH, EN HIGH
      await sleep(20);

      // Hold BOOT low
      await setBOOT_EN(true, false, 'BOOTFLOW');  // BOOT LOW, EN HIGH
      await sleep(40);

      // EN pulse (active-low), BOOT remains low
      await setBOOT_EN(true, true, 'BOOTFLOW');   // EN LOW
      await sleep(150);
      await setBOOT_EN(true, false, 'BOOTFLOW');  // EN HIGH -> sample BOOT LOW -> ROM loader
      w('BOOTFLOW: EN rising occurred with GPIO0 LOW (device should be in ROM loader).');

      // Release BOOT afterwards
      await sleep(120);
      await setBOOT_EN(false, false, 'BOOTFLOW'); // BOOT HIGH, EN HIGH
      await sleep(60);
    }, 'BOOTFLOW');
    w('BOOTFLOW: Completed.');
  }

  // ---------- Run App (GPIO0 HIGH @ EN rising) ----------
  async function runApp() {
    logMapping('RUNFLOW');
    w('RUNFLOW: Begin (GPIO0 HIGH at EN rising) …');
    await withOpenPort(async () => {
      // Ensure BOOT released, then pulse EN
      await setBOOT_EN(false, false, 'RUNFLOW'); // idle
      await setBOOT_EN(false, true , 'RUNFLOW'); // EN LOW
      await sleep(150);
      await setBOOT_EN(false, false, 'RUNFLOW'); // EN HIGH -> run app
      await sleep(180);
    }, 'RUNFLOW');
    w('RUNFLOW: Completed.');
  }

  // ---------- Button: Open & Select Port ----------
  btnOpen.onclick = async () => {
    try {
      if (!('serial' in navigator)) throw new Error('Web Serial not available (use Chrome/Edge over HTTPS).');
      w(`ENV: UA=${navigator.userAgent}`);

      port = await navigator.serial.requestPort({ filters: FILTERS });
      const info = port.getInfo?.()||{};
      w(`OPEN: Selected port -> VID=0x${(info.usbVendorId||0).toString(16)} PID=0x${(info.usbProductId||0).toString(16)}`);

      // Transport/loader constructed fresh for each connect
      transport = null; loader = null;

      btnBoot.disabled = false;
      btnConnect.disabled = false;
      btnRun.disabled = false;
      btnClose.disabled = false;
      btnOpen.disabled = true;

      logMapping('MAP');

    } catch (e) {
      w(`OPEN: FAILED: ${e?.message||e}`);
    }
  };

  // ---------- Button: Enter Bootloader ----------
  btnBoot.onclick = async () => {
    if (!port) { w('BOOT: port not selected.'); return; }
    await enterBootloader();
  };

  // ---------- Button: Connect (esptool-js) with guarded retry ----------
  btnConnect.onclick = async () => {
    if (!port) { w('CONNECT: port not selected.'); return; }

    // esptool-js should own open/close during connect()
    try { await port.close(); } catch {}
    transport = new Transport(port, false, false);
    loader = new ESPLoader({ transport, baudrate: OPEN_BAUD, terminal: term });

    // Attempt 1
    try {
      w('CONNECT: Short settle before ESPLoader.connect() …');
      await sleep(60);
      w('CONNECT: Calling ESPLoader.connect() (attempt 1) …');
      await loader.connect();
      w('CONNECT: SUCCESS (attempt 1)');
      return;
    } catch (e) {
      w(`CONNECT: attempt 1 FAILED: ${e?.message||e}`);
    }

    // Retry once: stronger boot pulse (with current mapping), then connect
    try {
      w('CONNECT: Retrying with stronger boot pulse …');
      await withOpenPort(async () => {
        await setBOOT_EN(false, false, 'RETRY');
        await sleep(40);
        await setBOOT_EN(true , false, 'RETRY'); // BOOT LOW
        await sleep(60);
        await setBOOT_EN(true , true , 'RETRY'); // EN LOW
        await sleep(200);
        await setBOOT_EN(true , false, 'RETRY'); // EN HIGH -> ROM loader
        w('BOOTFLOW: (retry) EN rising with GPIO0 LOW');
        await sleep(150);
        await setBOOT_EN(false, false, 'RETRY'); // release BOOT
        await sleep(80);
      }, 'RETRY');

      w('CONNECT: Calling ESPLoader.connect() (attempt 2) …');
      await loader.connect();
      w('CONNECT: SUCCESS (attempt 2)');
    } catch (e2) {
      w(`CONNECT: attempt 2 FAILED: ${e2?.message||e2}`);
      w('HINT: If both attempts failed, try switching the mapping selector (A ↔ B) and repeat: Enter Bootloader → Connect.');
    }
  };

  // ---------- Button: Run App ----------
  btnRun.onclick = async () => {
    if (!port) { w('RUN: port not selected.'); return; }
    await runApp();
  };

  // ---------- Button: Disconnect & Close ----------
  btnClose.onclick = async () => {
    w('CLOSE: Begin cleanup …');
    try { await transport?.disconnect?.(); w('CLOSE: transport.disconnect() OK'); } catch(e){ w(`CLOSE: transport.disconnect() err: ${e?.message||e}`); }
    try { await loader?.flashFinish?.(false); w('CLOSE: loader.flashFinish(false) OK'); } catch(e){ w(`CLOSE: flashFinish(false) err: ${e?.message||e}`); }
    try { await port?.close?.(); w('CLOSE: port.close() OK'); } catch(e){ w(`CLOSE: port.close() err: ${e?.message||e}`); }
    port=transport=loader=null;
    btnOpen.disabled=false; btnBoot.disabled=true; btnConnect.disabled=true; btnRun.disabled=true; btnClose.disabled=true;
    w('CLOSE: Completed.');
  };

  // ---------- On unload ----------
  window.addEventListener('unload',()=>{
    try{ transport?.disconnect?.(); }catch{}
    try{ port?.close?.(); }catch{}
  });

  w('READY: Test page loaded. 1) Open & Select Port → 2) Enter Bootloader → 3) Connect → 4) Run App → 5) Disconnect.');
</script>


</body>
</html>
