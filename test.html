<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>BTAudio – Minimal Flash Test</title>
  <style>
    :root{--bg:#121212;--panel:#1e1e1e;--text:#eaeaea;--muted:#bbb;--accent:#4CAF50;--accent2:#43a047;--border:rgba(255,255,255,.08)}
    *{box-sizing:border-box}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;max-width:820px;margin:36px auto;padding:20px;background:var(--bg);color:var(--text)}
    h1{margin:0 0 6px} .muted{color:var(--muted)}
    .panel{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:18px;margin:16px 0}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    button{background:var(--accent);color:#fff;border:none;padding:10px 14px;border-radius:8px;font-weight:600;cursor:pointer}
    button[disabled]{opacity:.55;cursor:not-allowed}
    button:hover:not([disabled]){background:var(--accent2)}
    textarea{width:100%;height:360px;border-radius:8px;border:1px solid var(--border);background:#0f0f0f;color:#cfe8ff;padding:10px;font-family:ui-monospace,Menlo,Consolas,monospace}
    code{background:#0f0f0f;padding:2px 6px;border-radius:6px;border:1px solid var(--border)}
  </style>
</head>
<body>
  <h1>BTAudio – Minimal Flash Test v19</h1>
  <p class="muted">Only what we need: <strong>Connect</strong> → <strong>Flash</strong>. Extra logging everywhere.</p>

  <div class="panel">
    <div class="row">
      <button id="btnConnect"  disabled>Connect</button>
      <button id="btnFlash"    disabled>Flash</button>
      <button id="btnDisconnect" disabled>Disconnect</button>
    </div>
    <div class="muted" style="margin-top:6px">
      Binary: <code id="binUrlLabel">https://nollstead.github.io/BTAudio/webflash/BTAudio.bin</code> @ <code>0x000000</code>
    </div>
  </div>

  <div class="panel">
    <h3>Log</h3>
    <textarea id="log" readonly></textarea>
  </div>

  <!-- esptool-js -->
  <script type="module">
    /********************************************************************
     * Minimal Flash Test
     * - Connect: let esptool-js own auto-reset and sync
     * - Flash: erase (optional) -> writeFlash -> flashFinish(true)
     * - No manual DTR/RTS or mapping logic
     ********************************************************************/

    import * as esptool from 'https://unpkg.com/esptool-js@0.5.7/bundle.js';
    const { ESPLoader, Transport } = esptool;

    // -------- Config (edit as needed) ----------
    const OPEN_BAUD    = 115200;   // initial connect baud
    const FAST_BAUD    = 921600;   // after stub
    const ERASE_FIRST  = true;     // set to false to skip erase
    const BIN_URL      = 'https://nollstead.github.io/BTAudio/webflash/BTAudio.bin';
    const BIN_ADDRESS  = 0x000000; // merged image at 0x0
    const FILTERS = [
      { usbVendorId: 0x10c4 },                      // CP210x (LyraT)
      { usbVendorId: 0x1a86, usbProductId: 0x7523 } // CH340C (SparkFun)
    ];

    // ---------- Logging ----------
    const logEl = document.getElementById('log');
    const w = (s)=>{ logEl.value += `[${new Date().toLocaleTimeString()}] ${s}\n`; logEl.scrollTop = logEl.scrollHeight; };
    const term = { clean(){}, writeLine(s){ if(s) w(`ESPLoader: ${s}`); }, write(s){ if(s) w(`ESPLoader: ${s}`); } };

    // ---------- DOM ----------
    const btnConnect    = document.getElementById('btnConnect');
    const btnFlash      = document.getElementById('btnFlash');
    const btnDisconnect = document.getElementById('btnDisconnect');
    document.getElementById('binUrlLabel').textContent = BIN_URL;

    // ---------- State ----------
    let port=null, transport=null, loader=null, connected=false, stubReady=false;

    // ---------- Helpers ----------
    const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));

    
// Convert Uint8Array -> binary string (compatible with browser bundles that
// still call .charCodeAt() internally during writeFlash)
function u8ToBinaryString(u8) {
  let s = '';
  const CHUNK = 1 << 15; // 32 KB
  for (let i = 0; i < u8.length; i += CHUNK) {
    s += String.fromCharCode.apply(null, u8.subarray(i, i + CHUNK));
  }
  return s;
}

// ---------- Connect ----------
btnConnect.onclick = async () => {
  btnConnect.disabled = true;
  try {
    if (!('serial' in navigator)) throw new Error('Web Serial not available (use Chrome/Edge over HTTPS).');
    w(`ENV: UA=${navigator.userAgent}`);

    // Let user pick a port (shows both CP210x + CH340 because of your FILTERS)
    port = await navigator.serial.requestPort({ filters: FILTERS });
    const info = port.getInfo?.()||{};
    const vendorId  = info.usbVendorId  || 0;
    const productId = info.usbProductId || 0;

    w(`CONNECT: Selected port -> VID=0x${vendorId.toString(16)} PID=0x${productId.toString(16)}`);

    switch (vendorId) {
      // --- CP210x / LyraT ---
      case 0x10c4: {
        // Proceed with your known-good flow
        transport = new Transport(port, /*tracing*/ false, /*enableSlipReader*/ false);
        loader = new ESPLoader({ transport, baudrate: OPEN_BAUD, terminal: term });

        w('CONNECT: Calling ESPLoader.connect() …');
        await loader.connect();
        connected = true;
        w('CONNECT: SUCCESS');

        // Upload stub → high baud
        try {
          w('STUB: Uploading/running stub …');
          await (typeof loader.runStub==='function' ? loader.runStub() : loader.loadStub());
          stubReady = true;
          w('STUB: Stub running.');
        } catch (e) {
          w(`STUB: Stub load failed (continuing): ${e?.message || e}`);
        }

        try {
          w(`BAUD: Changing baudrate to ${FAST_BAUD} …`);
          await loader.changeBaud(FAST_BAUD);
          w('BAUD: Changed.');
        } catch (e) {
          w(`BAUD: Change failed (continuing at ${OPEN_BAUD}): ${e?.message||e}`);
        }

        // Flash ID & size (informational)
        try {
          const id = await loader.flashId();
          if (id) {
            const man = (id >> 16) & 0xff, dev = id & 0xffff;
            w(`FLASHID: Manufacturer=0x${man.toString(16)} Device=0x${dev.toString(16)}`);
          }
        } catch (e) { w(`FLASHID: Failed: ${e?.message||e}`); }
        try {
          if (typeof loader.detectFlashSize === 'function') {
            const sizeStr = await loader.detectFlashSize();
            w(`FLASHID: Detected flash size = ${sizeStr}`);
          }
        } catch (e) { w(`FLASHID: Size detect failed: ${e?.message||e}`); }

        btnFlash.disabled = !connected;
        btnDisconnect.disabled = !connected;
        break;
      }

      // --- CH340 / SparkFun ---
      case 0x1a86: {
        w('CONNECT: Detected CH340 (SparkFun). Using CH340-specific connect flow.');
        const ok = await connectCH340(port, { baud: OPEN_BAUD });
        if (!ok) {
          btnConnect.disabled = false;   // leave UI ready to retry
          return;
        }
        connected = true;
        // Stop here for your CH340 connect/disconnect validation (no stub/baud/etc.)
        btnFlash.disabled = !connected;
        btnDisconnect.disabled = !connected;
        break;
      }

      // --- Anything else ---
      default: {
        w('CONNECT: Unsupported USB bridge for this test page. For now, only CP210x is enabled.');
        btnConnect.disabled = false;
        return;
      }
    }
  } catch (e) {
    w(`CONNECT: FAILED: ${e?.name?e.name+': ':''}${e?.message || e}`);
    try { await port?.close?.(); } catch {}
    btnConnect.disabled = false;
  }
};


// CH340 connect that mimics "click twice": do the same pre-boot+connect N times.
// Mapping (SparkFun CH340 on Windows): RTS -> BOOT (GPIO0, active-LOW), DTR -> EN (reset, active-LOW)
async function connectCH340(
  port,
  {
    baud            = OPEN_BAUD,
    cycles          = 3,     // try 2–3; your logs show #2 often succeeds
    neutral         = 100,   // ms
    bootHoldBefore  = 220,   // ms BOOT low before touching EN
    enLow           = 350,   // ms EN low (reset width)
    bootHoldAfter   = 280,   // ms keep BOOT low after EN rises (ride EN RC)
    finalSettle     = 140,   // ms settle after releasing BOOT
    settleBetween   = 150,   // ms between a pre-boot and connect
    settleBetweenCycles = 150, // ms between cycles
    probe           = true   // upload stub + flashId after connect to confirm ROM/stub
  } = {}
) {

  async function prebootCycle(tag) {
    // Ensure native port is closed, then open and drive BOTH signals each call (CH340 quirk).
    try { await port.close(); } catch {}
    w(`${tag}: port.open() …`);
    await port.open({ baudRate: baud });
    w(`${tag}: port.open() OK`);

    // 0) Neutral: EN=HIGH (DTR=false), BOOT=HIGH (RTS=false)
    w(`${tag}: Neutral (EN=HIGH, BOOT=HIGH) hold ${neutral}ms`);
    await port.setSignals({ dataTerminalReady: false, requestToSend: false });
    await sleep(neutral);

    // 1) BOOT=LOW (RTS=true) – settle before touching EN
    w(`${tag}: BOOT=LOW (RTS=true), EN=HIGH (DTR=false) hold ${bootHoldBefore}ms`);
    await port.setSignals({ dataTerminalReady: false, requestToSend: true });
    await sleep(bootHoldBefore);

    // 2) EN=LOW (DTR=true) while BOOT stays LOW
    w(`${tag}: EN=LOW (DTR=true), BOOT still LOW hold ${enLow}ms`);
    await port.setSignals({ dataTerminalReady: true, requestToSend: true });
    await sleep(enLow);

    // 3) EN=HIGH (DTR=false) — ROM samples IO0 LOW here
    w(`${tag}: EN=HIGH (DTR=false), BOOT still LOW (ROM samples) hold ${bootHoldAfter}ms`);
    await port.setSignals({ dataTerminalReady: false, requestToSend: true });
    await sleep(bootHoldAfter);

    // 4) BOOT=HIGH (RTS=false) — release after EN is cleanly high
    w(`${tag}: BOOT=HIGH (RTS=false) settle ${finalSettle}ms`);
    await port.setSignals({ dataTerminalReady: false, requestToSend: false });
    await sleep(finalSettle);

    // Close native port so esptool-js can own open() next
    try { await port.close(); w(`${tag}: port.close() OK`); }
    catch (e) { w(`${tag}: port.close() err: ${e?.message || e}`); }
  }

  for (let i = 1; i <= cycles; i++) {
    const tag = `CH340: pre-boot #${i}`;
    try {
      await prebootCycle(tag);
      await sleep(settleBetween);

      // Fresh transport/loader for this attempt
      transport = new Transport(port, /*tracing*/ false, /*enableSlipReader*/ false);
      loader    = new ESPLoader({ transport, baudrate: baud, terminal: term });

      w(`CONNECT(CH340): Attempt ${i} – ESPLoader.connect() …`);
      await loader.connect();
      w(`CONNECT(CH340): SUCCESS (attempt ${i})`);

      // Optional: verify we're really in ROM/stub (helps while we tune CH340)
      if (probe) {
        await sleep(120); // small settle; stay @115200 for CH340
        try {
          w('STUB(CH340): Uploading/running stub …');
          await (typeof loader.runStub==='function' ? loader.runStub() : loader.loadStub());
          w('STUB(CH340): Stub running (@115200).');

          // JEDEC probe after stub to avoid 0xFFFF reads
          w('PROBE(CH340): flashId() …');
          const id = await loader.flashId();
          if (typeof id === 'number') {
            const man = (id >>> 16) & 0xff;
            const dev = id & 0xffff;
            w(`PROBE(CH340): JEDEC -> Manufacturer=0x${man.toString(16)} Device=0x${dev.toString(16)}`);
          } else {
            w('PROBE(CH340): flashId returned non-number (continuing).');
          }
        } catch (e) {
          w(`PROBE/STUB(CH340): FAILED (continuing): ${e?.message || e}`);
        }
      }

      return true; // success on this attempt

    } catch (e) {
      w(`CONNECT(CH340): attempt ${i} FAILED: ${e?.message || e}`);

      // Cleanup before next cycle
      try { await transport?.disconnect?.(); } catch {}
      try {
        const stillOpen = !!(port && (port.readable || port.writable));
        if (stillOpen) { await port.close(); w('CH340: port.close() (cleanup) OK'); }
      } catch (e2) { w(`CH340: port.close() (cleanup) err: ${e2?.message || e2}`); }

      if (i < cycles) {
        w(`CH340: preparing next cycle … (sleep ${settleBetweenCycles}ms)`);
        await sleep(settleBetweenCycles);
      }
    }
  }

  // If we got here, all cycles failed
  return false;
}



    // ---------- Disconnect ----------
//btnDisconnect.onclick = safeDisconnect;
btnDisconnect.onclick = async () => {
  w('DISCONNECT: Begin cleanup …');

  // 1) Best‑effort esptool transport disconnect (this closes the port internally)
  try {
    await transport?.disconnect?.();
    w('DISCONNECT: transport.disconnect() OK');
  } catch (e) {
    w(`DISCONNECT: transport.disconnect() err: ${e?.message || e}`);
  }

  // 2) Only call port.close() if the port still appears open.
  //    Web Serial exposes readable/writable when open; when closed they are null/undefined.
  try {
    const stillOpen = !!(port && (port.readable || port.writable));
    if (stillOpen) {
      await port.close();
      w('DISCONNECT: port.close() OK (fallback close)');
    } else {
      w('DISCONNECT: port already closed (no-op)');
    }
  } catch (e) {
    // Swallow benign "already closed" noise
    if (String(e?.message || '').includes('already closed')) {
      w('DISCONNECT: port.close() skipped (already closed).');
    } else {
      w(`DISCONNECT: port.close() err: ${e?.message || e}`);
    }
  }

  // 3) Reset local state/UI
  port = transport = loader = null;
  connected = false; stubReady = false;
  btnConnect.disabled = false; btnFlash.disabled = true; btnDisconnect.disabled = true;

  w('DISCONNECT: Completed.');
}


    // ---------- On unload ----------
    window.addEventListener('unload',()=>{
      try{ transport?.disconnect?.(); }catch{}
      try{ port?.close?.(); }catch{}
    });

    // Enable Connect when ESPLoader is present
    btnConnect.disabled = !(Transport && ESPLoader);
    w('READY: Minimal test loaded. Click Connect, then Flash.');
  </script>
</body>
</html>
