<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>BTAudio – Serial Reset Test (LyraT/CP2102N)</title>
  <style>
    :root{--bg:#121212;--panel:#1e1e1e;--text:#eaeaea;--muted:#bbb;--accent:#4CAF50;--accent2:#43a047;--border:rgba(255,255,255,.08)}
    *{box-sizing:border-box}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;max-width:820px;margin:36px auto;padding:20px;background:var(--bg);color:var(--text)}
    h1{margin:0 0 6px} .muted{color:var(--muted)}
    .panel{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:18px;margin:16px 0}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    button{background:var(--accent);color:#fff;border:none;padding:10px 14px;border-radius:8px;font-weight:600;cursor:pointer}
    button[disabled]{opacity:.55;cursor:not-allowed}
    button:hover:not([disabled]){background:var(--accent2)}
    textarea{width:100%;height:340px;border-radius:8px;border:1px solid var(--border);background:#0f0f0f;color:#cfe8ff;padding:10px;font-family:ui-monospace,Menlo,Consolas,monospace}
    code{background:#0f0f0f;padding:2px 6px;border-radius:6px;border:1px solid var(--border)}
  </style>
</head>
<body>
  <h1>BTAudio – Serial Reset Test v8</h1>
  <p class="muted">Purpose: validate **open → enter bootloader → esptool connect → run app → disconnect** using CP2102N (LyraT v4.3).</p>

  <div class="panel">
    <div class="row">
      <button id="btnOpen">Open &amp; Select Port</button>
      <button id="btnBoot" disabled>Enter Bootloader (DTR/RTS)</button>
      <button id="btnConnect" disabled>Connect (esptool‑js)</button>
      <button id="btnRun" disabled>Run App (EN pulse)</button>
      <button id="btnClose" disabled>Disconnect &amp; Close</button>
    </div>
    <p class="muted" style="margin-top:6px">
      Tips:
      <br/>• Use Chrome/Edge over HTTPS (Web Serial requirement).
      <br/>• Ensure no other serial app is holding the port.
      <br/>• If first connect fails, repeat the sequence: <code>Enter Bootloader → Connect</code>.
    </p>
  </div>

  <div class="panel">
    <h3>Log</h3>
    <textarea id="log" readonly></textarea>
  </div>



<script type="module">
  /********************************************************************
   * BTAudio – Serial Reset Test (LyraT/CP2102N, no mapping selector)
   * Wiring assumed (Espressif standard):
   *   DTR -> GPIO0 (BOOT), active-LOW
   *   RTS -> EN    (reset), active-LOW
   *
   * Enter Bootloader flow (mirrors hand sequence):
   *   BOOT=LOW (hold) -> EN=LOW (reset) -> EN=HIGH (sample) -> keep BOOT a bit -> BOOT=HIGH
   *
   * Ultra-verbose logs around every action + sleep.
   ********************************************************************/

  import * as esptool from 'https://unpkg.com/esptool-js@0.5.7/bundle.js';
  const { ESPLoader, Transport } = esptool;

  // ---------- Logging ----------
  const logEl = document.getElementById('log');
  const w = (s)=>{ logEl.value += `[${new Date().toLocaleTimeString()}] ${s}\n`; logEl.scrollTop = logEl.scrollHeight; };
  const term = { clean(){}, writeLine(s){ if(s) w(`ESPLoader: ${s}`); }, write(s){ if(s) w(`ESPLoader: ${s}`); } };

  // ---------- DOM ----------
  const btnOpen    = document.getElementById('btnOpen');
  const btnBoot    = document.getElementById('btnBoot');
  const btnConnect = document.getElementById('btnConnect');
  const btnRun     = document.getElementById('btnRun');
  const btnClose   = document.getElementById('btnClose');

  // ---------- State ----------
  let port=null, transport=null, loader=null;
  const OPEN_BAUD = 115200;
  const FAST_BAUD = 921600;
  const FILTERS = [{ usbVendorId: 0x10c4 }]; // CP210x (LyraT)
  const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));

  // DTR -> GPIO0 (BOOT), RTS -> EN (active-LOW)
  async function setSignalsRaw(dtr, rts, label='SIG') {
    const dtrStr = (dtr===true)?'true':(dtr===false)?'false':'(no change)';
    const rtsStr = (rts===true)?'true':(rts===false)?'false':'(no change)';
    w(`${label}: setSignals request  DTR=${dtrStr}, RTS=${rtsStr}`);
    try {
      await port.setSignals({
        dataTerminalReady: (dtr===undefined ? undefined : !!dtr),
        requestToSend:     (rts===undefined ? undefined : !!rts)
      });
      w(`${label}: setSignals applied DTR=${dtrStr}, RTS=${rtsStr}  -> OK`);
    } catch(e) {
      w(`${label}: setSignals FAILED (${e?.message||e})`);
      throw e;
    }
  }

  async function withOpenPort(fn, label='SIG') {
    // Defensive close in case the OS still holds it
    try { await port?.close?.(); } catch {}
    try {
      w(`${label}: opening port @ ${OPEN_BAUD} …`);
      await port.open({ baudRate: OPEN_BAUD });
      w(`${label}: port.open() OK`);
    } catch (e) {
      w(`${label}: port.open() FAILED: ${e?.message||e}`);
      throw e;
    }
    try {
      await fn();
    } finally {
      try { await port.close(); w(`${label}: port.close() OK`); }
      catch(e) { w(`${label}: port.close() err: ${e?.message||e}`); }
    }
  }

  // Handy sleep with logs
  async function debugSleep(ms, label) {
    w(`${label}: sleeping ${ms} ms …`);
    await sleep(ms);
    w(`${label}: woke after ${ms} ms`);
  }

  // ---------- ENTER BOOTLOADER (single “press” flow; no idle-then-low pre-step) ----------
  // Sequence:
  //   1) BOOT=LOW (DTR=true)
  //   2) wait (BOOT settle)
  //   3) EN=LOW  (RTS=true)
  //   4) wait (EN fully asserted; discharge EN RC)
  //   5) EN=HIGH (RTS=false)  <-- ROM samples GPIO0 here; must still be LOW
  //   6) wait (hold BOOT a bit longer to ride EN RC slope)
  //   7) BOOT=HIGH (DTR=false)
  async function enterBootloader() {
    w('BOOTFLOW: Begin (hold BOOT low, reset EN, then release EN while BOOT low)');

    await withOpenPort(async () => {
      // 1) BOOT = LOW (assert)
      w('BOOTFLOW: 1) BOOT=LOW (DTR=true) — asserting GPIO0 low');
      await setSignalsRaw(true, undefined, 'BOOTFLOW');
      await debugSleep(400, 'BOOTFLOW');          // allow BOOT to settle well before EN activity

      // 2) EN = LOW (assert reset)
      w('BOOTFLOW: 2) EN=LOW (RTS=true) — asserting reset low');
      await setSignalsRaw(undefined, true, 'BOOTFLOW');
      await debugSleep(400, 'BOOTFLOW');          // discharge EN RC; guarantee deep reset

      // 3) EN = HIGH (release reset) — ROM samples GPIO0 right here
      w('BOOTFLOW: 3) EN=HIGH (RTS=false) — releasing reset (ROM samples now)');
      await setSignalsRaw(undefined, false, 'BOOTFLOW');
      w('BOOTFLOW: NOTE: At this instant ROM samples GPIO0; it should be LOW to enter UART bootloader.');

      // 4) Keep BOOT low a little longer to ride out EN’s RC rise, then release
      await debugSleep(400, 'BOOTFLOW');          // keep BOOT low past EN threshold

      // 5) BOOT = HIGH (release)
      w('BOOTFLOW: 5) BOOT=HIGH (DTR=false) — releasing GPIO0');
      await setSignalsRaw(false, undefined, 'BOOTFLOW');

      await debugSleep(150, 'BOOTFLOW');          // small settle
    }, 'BOOTFLOW');

    w('BOOTFLOW: Completed.');
  }

  // ---------- RUN APP (GPIO0 HIGH at EN rising) ----------
  //   EN=LOW (reset) -> wait -> EN=HIGH (run)
  async function runApp() {
    w('RUNFLOW: Begin (GPIO0 HIGH at EN rising)');
    await withOpenPort(async () => {
      // Ensure BOOT stays HIGH: do not assert DTR at all in run flow

      // EN = LOW
      w('RUNFLOW: EN=LOW (RTS=true) — asserting reset low');
      await setSignalsRaw(undefined, true, 'RUNFLOW');
      await debugSleep(250, 'RUNFLOW');

      // EN = HIGH
      w('RUNFLOW: EN=HIGH (RTS=false) — releasing reset (should run app)');
      await setSignalsRaw(undefined, false, 'RUNFLOW');
      await debugSleep(250, 'RUNFLOW');
    }, 'RUNFLOW');
    w('RUNFLOW: Completed.');
  }

  // ---------- Button: Open & Select Port ----------
  btnOpen.onclick = async () => {
    try {
      if (!('serial' in navigator)) throw new Error('Web Serial not available (use Chrome/Edge over HTTPS).');
      w(`ENV: UA=${navigator.userAgent}`);

      port = await navigator.serial.requestPort({ filters: FILTERS });
      const info = port.getInfo?.()||{};
      w(`OPEN: Selected port -> VID=0x${(info.usbVendorId||0).toString(16)} PID=0x${(info.usbProductId||0).toString(16)}`);

      transport = null; loader = null; // always rebuilt for Connect()

      btnBoot.disabled = false;
      btnConnect.disabled = false;
      btnRun.disabled = false;
      btnClose.disabled = false;
      btnOpen.disabled = true;

      w('OPEN: Ready. Use "Enter Bootloader" next, then "Connect".');
    } catch (e) {
      w(`OPEN: FAILED: ${e?.message||e}`);
    }
  };


// ---------- Button: Enter Bootloader ----------
// No-op now. We rely on ESPLoader.connect() to perform the DevKitC auto-reset.
// Keep this for diagnostics only, so we don't disturb the state right before connect.
btnBoot.onclick = async () => {
  w('BOOT: Skipped manual control-lines. Use CONNECT; ESPLoader.connect() performs the standard auto-reset on LyraT (DevKitC wiring).');
};


  // ---------- Button: Connect (esptool-js) with one guarded retry ----------
  btnConnect.onclick = async () => {
    if (!port) { w('CONNECT: port not selected.'); return; }

    // Ensure native port is closed so esptool-js owns open/close inside connect()
    try { await port.close(); } catch {}

    transport = new Transport(port, false, false);
    loader = new ESPLoader({ transport, baudrate: OPEN_BAUD, terminal: term });

    // Attempt 1
    try {
      w('CONNECT: Short settle before ESPLoader.connect() …');
      await sleep(80);
      w('CONNECT: Calling ESPLoader.connect() (attempt 1) …');
      await loader.connect();
      w('CONNECT: SUCCESS (attempt 1)');
      return;
    } catch (e) {
      w(`CONNECT: attempt 1 FAILED: ${e?.message||e}`);
    }

    // Retry once: re-run the same press flow, then connect again
    try {
      w('CONNECT: Retrying — re-running BOOT press flow …');
      await enterBootloader();

      w('CONNECT: Calling ESPLoader.connect() (attempt 2) …');
      await loader.connect();
      w('CONNECT: SUCCESS (attempt 2)');
    } catch (e2) {
      w(`CONNECT: attempt 2 FAILED: ${e2?.message||e2}`);
      w('HINT: If LED turns back ON during BOOTFLOW, IO0 may be released too early; we can extend holds further.');
    }
  };

  // ---------- Button: Run App ----------
  btnRun.onclick = async () => {
    if (!port) { w('RUN: port not selected.'); return; }
    await runApp(); // LED should go ON immediately
  };

  // ---------- Button: Disconnect & Close ----------
  btnClose.onclick = async () => {
    w('CLOSE: Begin cleanup …');
    try { await transport?.disconnect?.(); w('CLOSE: transport.disconnect() OK'); } catch(e){ w(`CLOSE: transport.disconnect() err: ${e?.message||e}`); }
    try { await loader?.flashFinish?.(false); w('CLOSE: loader.flashFinish(false) OK'); } catch(e){ w(`CLOSE: flashFinish(false) err: ${e?.message||e}`); }
    try { await port?.close?.(); w('CLOSE: port.close() OK'); } catch(e){ w(`CLOSE: port.close() err: ${e?.message||e}`); }
    port=transport=loader=null;
    btnOpen.disabled=false; btnBoot.disabled=true; btnConnect.disabled=true; btnRun.disabled=true; btnClose.disabled=true;
    w('CLOSE: Completed.');
  };

  // ---------- On unload ----------
  window.addEventListener('unload',()=>{
    try{ transport?.disconnect?.(); }catch{}
    try{ port?.close?.(); }catch{}
  });

  w('READY: Test page loaded. 1) Open & Select Port → 2) Enter Bootloader → 3) Connect → 4) Run App → 5) Disconnect.');
</script>


</body>
</html>
