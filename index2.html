
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>BTAudio Uploader – Manual Boot (SparkFun test) v3</title>
<style>
  :root{--bg:#121212;--panel:#1e1e1e;--text:#eaeaea;--muted:#bbb;--accent:#4CAF50;--accent2:#43a047;--border:rgba(255,255,255,.08)}
  *{box-sizing:border-box}
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;max-width:780px;margin:48px auto;padding:20px;background:var(--bg);color:var(--text)}
  h1{margin:0 0 8px}.muted{color:var(--muted)}
  .panel{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:20px;margin:18px 0;box-shadow:0 0 20px rgba(0,0,0,.35)}
  .row{display:flex;gap:10px;flex-wrap:wrap;margin:16px 0}
  button{background:var(--accent);color:#fff;border:none;padding:12px 18px;border-radius:10px;font-weight:600;cursor:pointer}
  button[disabled]{opacity:.55;cursor:not-allowed}
  button:hover:not([disabled]){background:var(--accent2)}
  textarea{width:100%;height:260px;border-radius:8px;border:1px solid var(--border);background:#0f0f0f;color:#cfe8ff;padding:10px;font-family:ui-monospace,Menlo,Consolas,monospace}
</style>
</head>
<body>
  <h1>BTAudio Firmware Uploader (Manual Boot mode)</h1>
  <p class="muted">
    Breadboard tip: add a <b>0.1 µF</b> capacitor from <b>EN → GND</b> to improve reset timing margin.
  </p>

  <div class="panel">
    <div class="row">
      <button id="connectManualBtn" disabled>Connect (Manual Boot)</button>
      <button id="flashBtn" disabled>Upload</button>
      <button id="disconnectBtn" disabled>Disconnect</button>
    </div>
    <ol class="muted">
      <li>Place a jumper so <b>GPIO0 ↔ GND</b> (hold BOOT).</li>
      <li><b>Unplug</b> USB, then <b>plug back in</b> (power cycle) — the board is now in the ROM bootloader.</li>
      <li>Remove the GPIO0↔GND jumper (release BOOT).</li>
      <li>Click <b>Connect (Manual Boot)</b>. No DTR/RTS toggles are used.</li>
    </ol>
  </div>

  <div class="panel">
    <h3>Log</h3>
    <textarea id="log" readonly></textarea>
  </div>

  <script type="module">
    import * as esptool from 'https://unpkg.com/esptool-js@0.5.7/bundle.js';
    const { ESPLoader, Transport } = esptool;

    const logEl = document.getElementById('log');
    const connectManualBtn = document.getElementById('connectManualBtn');
    const flashBtn = document.getElementById('flashBtn');
    const disconnectBtn = document.getElementById('disconnectBtn');
    const log = (m,e=false)=>{ const ts=new Date().toLocaleTimeString();
      logEl.value+=`[${ts}] ${m}\n`; logEl.scrollTop=logEl.scrollHeight;
      (e?console.error:console.log)(m); };

    let port=null, transport=null, loader=null, connecting=false;
    const BAUD=115200;
    const FILTERS=[{ usbVendorId:0x1a86, usbProductId:0x7523 }]; // SparkFun CH340C
    const sleep=(ms)=>new Promise(r=>setTimeout(r,ms));

    async function disconnectClean(){
      try { try{ await transport?.disconnect?.(); }catch{}; try{ await loader?.flashFinish?.(false); }catch{}; }
      finally {
        try{ await port?.close?.(); }catch{};
        loader=transport=port=null; await sleep(100);
        connectManualBtn.disabled=false; flashBtn.disabled=true; disconnectBtn.disabled=true;
        log('Disconnected and port closed.');
      }
    }
    disconnectBtn.onclick=disconnectClean;

    // Manual-boot connect: NO DTR/RTS, no before-reset; just sync to ROM loader now running
    connectManualBtn.onclick = async ()=>{
      if (connecting) return; connecting=true;
      connectManualBtn.disabled=true;
      try{
        port = await navigator.serial.requestPort({ filters: FILTERS });
        log('Port selected.');

        transport = new Transport(port, /*tracing*/ false, /*enableSlipReader*/ false);
        loader = new ESPLoader({
          transport,
          baudrate: BAUD,
          terminal: { clean(){ logEl.value=''; }, writeLine(s){ log(s); }, write(s){ log(s); } }
        });

        // Ask loader to skip its own pre-reset (equivalent to esptool.py --before no_reset)
        try { loader.before = 'no_reset'; } catch {}

        // Ensure closed before connect; then try multiple sync attempts (user just power-cycled)
        if (port.readable || port.writable) {
          try { await transport.disconnect(); } catch {}
          try { await port.close(); } catch {}
          await sleep(120);
        }

        let ok=false, lastErr=null;
        for (let i=0;i<6 && !ok;i++){
          try { await loader.connect(); ok=true; }
          catch(e){ lastErr=e; await sleep(300); }
        }
        if (!ok) throw lastErr || new Error('Sync timeout.');

        const chip = await loader.chip;
        log(`Connected (no-reset) → ${chip}`);
        flashBtn.disabled=false; disconnectBtn.disabled=false;

      } catch(e){
        log(`Connect failed (manual boot): ${e?.name?e.name+': ':''}${e?.message||e}`, true);
        connectManualBtn.disabled=false;
      } finally { connecting=false; }
    };

    // Flash a single binary at 0x000000
    flashBtn.onclick = async ()=>{
      flashBtn.disabled=true;
      try {
        const resp = await fetch('webflash/UTAudio.bin', { cache:'no-cache' });
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const buf = new Uint8Array(await resp.arrayBuffer());
        log(`Image size: ${buf.length} bytes`);

        try{
          if (!loader.IS_STUB){ log('Running stub…');
            await (typeof loader.runStub==='function'?loader.runStub():loader.loadStub());
            log('Stub ready.');
          } else { log('Stub already running — skipping stub load.'); }
        } catch(e){ log(`Stub load failed (continuing with ROM): ${e?.message||e}`, true); }

        await loader.eraseFlash();

        let bstr=''; for (let i=0;i<buf.length;i++) bstr+=String.fromCharCode(buf[i]);
        await loader.writeFlash({
          fileArray: [{ address: 0x000000, data: bstr }],
          flashSize:'16MB', flashMode:'keep', flashFreq:'keep', compress:true,
          reportProgress:(i,w,t)=>{ if(t>0) log(`Writing… ${Math.round((w/t)*100)}%`); }
        });

        log('Flash complete. Power-cycle the board to run your app.');
        await disconnectClean();

      } catch(e){
        log(`Flash failed: ${e?.message||e}`, true);
        flashBtn.disabled=false;
      }
    };

    window.addEventListener('unload', ()=>{
      try{ transport?.disconnect?.(); }catch{}
      try{ port?.close?.(); }catch{}
    });

    log('Manual-boot installer loaded.');
    connectManualBtn.disabled = !(Transport && ESPLoader);
  </script>
</body>
</html>
